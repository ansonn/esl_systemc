The cudd package

The University of Colorado decision diagram package.

Fabio Somenzi

**********************************************************************

Cudd_ApaAdd()                  Adds two arbitrary precision integers.

Cudd_ApaCompareRatios()        Compares the ratios of two arbitrary precision
                               integers to two unsigned ints.

Cudd_ApaCompare()              Compares two arbitrary precision integers.

Cudd_ApaCopy()                 Makes a copy of an arbitrary precision integer.

Cudd_ApaCountMinterm()         Counts the number of minterms of a DD.

Cudd_ApaIntDivision()          Divides an arbitrary precision integer by an
                               integer.

Cudd_ApaNumberOfDigits()       Finds the number of digits for an arbitrary
                               precision integer.

Cudd_ApaPowerOfTwo()           Sets an arbitrary precision integer to a power
                               of two.

Cudd_ApaPrintDecimal()         Prints an arbitrary precision integer in
                               decimal format.

Cudd_ApaPrintDensity()         Prints the density of a BDD or ADD using
                               arbitrary precision arithmetic.

Cudd_ApaPrintExponential()     Prints an arbitrary precision integer in
                               exponential format.

Cudd_ApaPrintHex()             Prints an arbitrary precision integer in
                               hexadecimal format.

Cudd_ApaPrintMintermExp()      Prints the number of minterms of a BDD or ADD
                               in exponential format using arbitrary precision
                               arithmetic.

Cudd_ApaPrintMinterm()         Prints the number of minterms of a BDD or ADD
                               using arbitrary precision arithmetic.

Cudd_ApaSetToLiteral()         Sets an arbitrary precision integer to a one-
                               digit literal.

Cudd_ApaShiftRight()           Shifts right an arbitrary precision integer by
                               one binary place.

Cudd_ApaShortDivision()        Divides an arbitrary precision integer by a
                               digit.

Cudd_ApaSubtract()             Subtracts two arbitrary precision integers.

Cudd_AutodynDisableZdd()       Disables automatic dynamic reordering of ZDDs.

Cudd_AutodynDisable()          Disables automatic dynamic reordering.

Cudd_AutodynEnableZdd()        Enables automatic dynamic reordering of ZDDs.

Cudd_AutodynEnable()           Enables automatic dynamic reordering of BDDs
                               and ADDs.

Cudd_AverageDistance()         Computes the average distance between adjacent
                               nodes.

Cudd_BddToAdd()                Converts a BDD to a 0-1 ADD.

Cudd_BiasedOverApprox()        Extracts a dense superset from a BDD with the
                               biased underapproximation method.

Cudd_BiasedUnderApprox()       Extracts a dense subset from a BDD with the
                               biased underapproximation method.

Cudd_CProjection()             Computes the compatible projection of R w.r.t.
                               cube Y.

Cudd_CheckKeys()               Checks for several conditions that should not
                               occur.

Cudd_CheckZeroRef()            Checks the unique table for nodes with non-zero
                               reference counts.

Cudd_ClassifySupport()         Classifies the variables in the support of two
                               DDs.

Cudd_ClearErrorCode()          Clear the error code of a manager.

Cudd_CofMinterm()              Computes the fraction of minterms in the on-set
                               of all the positive cofactors of a BDD or ADD.

Cudd_Cofactor()                Computes the cofactor of f with respect to g.

Cudd_Complement()              Returns the complemented version of a pointer.

Cudd_CountLeaves()             Counts the number of leaves in a DD.

Cudd_CountMinterm()            Counts the number of minterms of a DD.

Cudd_CountPath()               Counts the number of paths of a DD.

Cudd_DagSize()                 Counts the number of nodes in a DD.

Cudd_DeadAreCounted()          Tells whether dead nodes are counted towards
                               triggering reordering.

Cudd_DebugCheck()              Checks for inconsistencies in the DD heap.

Cudd_Decreasing()              Determines whether a BDD is negative unate in a
                               variable.

Cudd_DelayedDerefBdd()         Decreases the reference count of BDD node n.

Cudd_Density()                 Computes the density of a BDD or ADD.

Cudd_Deref()                   Decreases the reference count of node.

Cudd_DisableGarbageCollection()
                               Disables garbage collection.

Cudd_DisableReorderingReporting()
                               Disables reporting of reordering stats.

Cudd_DumpBlif()                Writes a blif file representing the argument
                               BDDs.

Cudd_DumpDDcal()               Writes a DDcal file representing the argument
                               BDDs.

Cudd_DumpDaVinci()             Writes a daVinci file representing the argument
                               BDDs.

Cudd_DumpDot()                 Writes a dot file representing the argument
                               DDs.

Cudd_DumpFactoredForm()        Writes factored forms representing the argument
                               BDDs.

Cudd_Dxygtdxz()                Generates a BDD for the function d(x,y) >
                               d(x,z).

Cudd_Dxygtdyz()                Generates a BDD for the function d(x,y) >
                               d(y,z).

Cudd_EnableGarbageCollection() Enables garbage collection.

Cudd_EnableReorderingReporting()
                               Enables reporting of reordering stats.

Cudd_EqualSupNorm()            Compares two ADDs for equality within
                               tolerance.

Cudd_EquivDC()                 Tells whether F and G are identical wherever D
                               is 0.

Cudd_EstimateCofactorSimple()  Estimates the number of nodes in a cofactor of
                               a DD.

Cudd_EstimateCofactor()        Estimates the number of nodes in a cofactor of
                               a DD.

Cudd_Eval()                    Returns the value of a DD for a given variable
                               assignment.

Cudd_ExpectedUsedSlots()       Computes the expected fraction of used slots in
                               the unique table.

Cudd_E()                       Returns the else child of an internal node.

Cudd_FindEssential()           Finds the essential variables of a DD.

Cudd_FirstCube()               Finds the first cube of a decision diagram.

Cudd_FirstNode()               Finds the first node of a decision diagram.

Cudd_ForeachCube()             Iterates over the cubes of a decision diagram.

Cudd_ForeachNode()             Iterates over the nodes of a decision diagram.

Cudd_FreeTree()                Frees the variable group tree of the manager.

Cudd_FreeZddTree()             Frees the variable group tree of the manager.

Cudd_GarbageCollectionEnabled()
                               Tells whether garbage collection is enabled.

Cudd_GenFree()                 Frees a CUDD generator.

Cudd_Increasing()              Determines whether a BDD is positive unate in a
                               variable.

Cudd_IndicesToCube()           Builds a cube of BDD variables from an array of
                               indices.

Cudd_Init()                    Creates a new DD manager.

Cudd_IsComplement()            Returns 1 if a pointer is complemented.

Cudd_IsConstant()              Returns 1 if the node is a constant node.

Cudd_IsGenEmpty()              Queries the status of a generator.

Cudd_IsNonConstant()           Returns 1 if a DD node is not constant.

Cudd_IterDerefBdd()            Decreases the reference count of BDD node n.

Cudd_LargestCube()             Finds a largest cube in a DD.

Cudd_MakeBddFromZddCover()     Converts a ZDD cover to a BDD graph.

Cudd_MakeTreeNode()            Creates a new variable group.

Cudd_MakeZddTreeNode()         Creates a new ZDD variable group.

Cudd_MinHammingDist()          Returns the minimum Hamming distance between f
                               and minterm.

Cudd_NewApaNumber()            Allocates memory for an arbitrary precision
                               integer.

Cudd_NextCube()                Generates the next cube of a decision diagram
                               onset.

Cudd_NextNode()                Finds the next node of a decision diagram.

Cudd_NodeReadIndex()           Returns the index of the node.

Cudd_NotCond()                 Complements a DD if a condition is true.

Cudd_Not()                     Complements a DD.

Cudd_OutOfMem()                Warns that a memory allocation failed.

Cudd_OverApprox()              Extracts a dense superset from a BDD with
                               Shiple's underapproximation method.

Cudd_Prime()                   Returns the next prime >= p.

Cudd_PrintDebug()              Prints to the standard output a DD and its
                               statistics.

Cudd_PrintInfo()               Prints out statistics and settings for a CUDD
                               manager.

Cudd_PrintLinear()             Prints the linear transform matrix.

Cudd_PrintMinterm()            Prints a disjoint sum of products.

Cudd_PrintVersion()            Prints the package version number.

Cudd_Quit()                    Deletes resources associated with a DD manager.

Cudd_Random()                  Portable random number generator.

Cudd_ReadArcviolation()        Returns the current value of the arcviolation
                               parameter used in group sifting.

Cudd_ReadBackground()          Reads the background constant of the manager.

Cudd_ReadCacheHits()           Returns the number of cache hits.

Cudd_ReadCacheLookUps()        Returns the number of cache look-ups.

Cudd_ReadCacheSlots()          Reads the number of slots in the cache.

Cudd_ReadCacheUsedSlots()      Reads the fraction of used slots in the cache.

Cudd_ReadDead()                Returns the number of dead nodes in the unique
                               table.

Cudd_ReadEpsilon()             Reads the epsilon parameter of the manager.

Cudd_ReadErrorCode()           Returns the code of the last error.

Cudd_ReadGarbageCollectionTime()
                               Returns the time spent in garbage collection.

Cudd_ReadGarbageCollections()  Returns the number of times garbage collection
                               has occurred.

Cudd_ReadGroupcheck()          Reads the groupcheck parameter of the manager.

Cudd_ReadIndex()               Returns the current position in the order of
                               variable index.

Cudd_ReadInvPermZdd()          Returns the index of the ZDD variable currently
                               in the i-th position of the order.

Cudd_ReadInvPerm()             Returns the index of the variable currently in
                               the i-th position of the order.

Cudd_ReadKeys()                Returns the number of nodes in the unique
                               table.

Cudd_ReadLinear()              Reads an entry of the linear transform matrix.

Cudd_ReadLogicZero()           Returns the logic zero constant of the manager.

Cudd_ReadLooseUpTo()           Reads the looseUpTo parameter of the manager.

Cudd_ReadMaxCacheHard()        Reads the maxCacheHard parameter of the
                               manager.

Cudd_ReadMaxCache()            Returns the soft limit for the cache size.

Cudd_ReadMaxGrowth()           Reads the maxGrowth parameter of the manager.

Cudd_ReadMaxLive()             Reads the maximum allowed number of live nodes.

Cudd_ReadMaxMemory()           Reads the maximum allowed memory.

Cudd_ReadMemoryInUse()         Returns the memory in use by the manager
                               measured in bytes.

Cudd_ReadMinDead()             Reads the minDead parameter of the manager.

Cudd_ReadMinHit()              Reads the hit ratio that causes resizinig of
                               the computed table.

Cudd_ReadMinusInfinity()       Reads the minus-infinity constant from the
                               manager.

Cudd_ReadNextReordering()      Returns the threshold for the next dynamic
                               reordering.

Cudd_ReadNodeCount()           Reports the number of nodes in BDDs and ADDs.

Cudd_ReadNodesDropped()        Returns the number of nodes dropped.

Cudd_ReadNodesFreed()          Returns the number of nodes freed.

Cudd_ReadNumberXovers()        Reads the current number of crossovers used by
                               the genetic algorithm for reordering.

Cudd_ReadOne()                 Returns the one constant of the manager.

Cudd_ReadPeakLiveNodeCount()   Reports the peak number of live nodes.

Cudd_ReadPeakNodeCount()       Reports the peak number of nodes.

Cudd_ReadPermZdd()             Returns the current position of the i-th ZDD
                               variable in the order.

Cudd_ReadPerm()                Returns the current position of the i-th
                               variable in the order.

Cudd_ReadPlusInfinity()        Reads the plus-infinity constant from the
                               manager.

Cudd_ReadPopulationSize()      Reads the current size of the population used
                               by the genetic algorithm for reordering.

Cudd_ReadRecomb()              Returns the current value of the recombination
                               parameter used in group sifting.

Cudd_ReadRecursiveCalls()      Returns the number of recursive calls.

Cudd_ReadReorderingTime()      Returns the time spent in reordering.

Cudd_ReadReorderings()         Returns the number of times reordering has
                               occurred.

Cudd_ReadSiftMaxSwap()         Reads the siftMaxSwap parameter of the manager.

Cudd_ReadSiftMaxVar()          Reads the siftMaxVar parameter of the manager.

Cudd_ReadSize()                Returns the number of BDD variables in
                               existance.

Cudd_ReadSlots()               Returns the total number of slots of the unique
                               table.

Cudd_ReadStderr()              Reads the stderr of a manager.

Cudd_ReadStdout()              Reads the stdout of a manager.

Cudd_ReadSwapSteps()           Reads the number of elementary reordering
                               steps.

Cudd_ReadSymmviolation()       Returns the current value of the symmviolation
                               parameter used in group sifting.

Cudd_ReadTree()                Returns the variable group tree of the manager.

Cudd_ReadUniqueLinks()         Returns the number of links followed in the
                               unique table.

Cudd_ReadUniqueLookUps()       Returns the number of look-ups in the unique
                               table.

Cudd_ReadUsedSlots()           Reads the fraction of used slots in the unique
                               table.

Cudd_ReadVars()                Returns the i-th element of the vars array.

Cudd_ReadZddOne()              Returns the ZDD for the constant 1 function.

Cudd_ReadZddSize()             Returns the number of ZDD variables in
                               existance.

Cudd_ReadZddTree()             Returns the variable group tree of the manager.

Cudd_ReadZero()                Returns the zero constant of the manager.

Cudd_RecursiveDerefZdd()       Decreases the reference count of ZDD node n.

Cudd_RecursiveDeref()          Decreases the reference count of node n.

Cudd_ReduceHeap()              Main dynamic reordering routine.

Cudd_Ref()                     Increases the reference count of a node, if it
                               is not saturated.

Cudd_Regular()                 Returns the regular version of a pointer.

Cudd_RemapOverApprox()         Extracts a dense superset from a BDD with the
                               remapping underapproximation method.

Cudd_RemapUnderApprox()        Extracts a dense subset from a BDD with the
                               remapping underapproximation method.

Cudd_ReorderingReporting()     Returns 1 if reporting of reordering stats is
                               enabled.

Cudd_ReorderingStatusZdd()     Reports the status of automatic dynamic
                               reordering of ZDDs.

Cudd_ReorderingStatus()        Reports the status of automatic dynamic
                               reordering of BDDs and ADDs.

Cudd_SetArcviolation()         Sets the value of the arcviolation parameter
                               used in group sifting.

Cudd_SetBackground()           Sets the background constant of the manager.

Cudd_SetEpsilon()              Sets the epsilon parameter of the manager to
                               ep.

Cudd_SetGroupcheck()           Sets the parameter groupcheck of the manager to
                               gc.

Cudd_SetLooseUpTo()            Sets the looseUpTo parameter of the manager.

Cudd_SetMaxCacheHard()         Sets the maxCacheHard parameter of the manager.

Cudd_SetMaxGrowth()            Sets the maxGrowth parameter of the manager.

Cudd_SetMaxLive()              Sets the maximum allowed number of live nodes.

Cudd_SetMaxMemory()            Sets the maximum allowed memory.

Cudd_SetMinHit()               Sets the hit ratio that causes resizinig of the
                               computed table.

Cudd_SetNextReordering()       Sets the threshold for the next dynamic
                               reordering.

Cudd_SetNumberXovers()         Sets the number of crossovers used by the
                               genetic algorithm for reordering.

Cudd_SetPopulationSize()       Sets the size of the population used by the
                               genetic algorithm for reordering.

Cudd_SetRecomb()               Sets the value of the recombination parameter
                               used in group sifting.

Cudd_SetSiftMaxSwap()          Sets the siftMaxSwap parameter of the manager.

Cudd_SetSiftMaxVar()           Sets the siftMaxVar parameter of the manager.

Cudd_SetStderr()               Sets the stderr of a manager.

Cudd_SetStdout()               Sets the stdout of a manager.

Cudd_SetSymmviolation()        Sets the value of the symmviolation parameter
                               used in group sifting.

Cudd_SetTree()                 Sets the variable group tree of the manager.

Cudd_SetVarMap()               Registers a variable mapping with the manager.

Cudd_SetZddTree()              Sets the ZDD variable group tree of the
                               manager.

Cudd_SharingSize()             Counts the number of nodes in an array of DDs.

Cudd_ShortestLength()          Find the length of the shortest path(s) in a
                               DD.

Cudd_ShortestPath()            Finds a shortest path in a DD.

Cudd_ShuffleHeap()             Reorders variables according to given
                               permutation.

Cudd_SolveEqn()                Implements the solution of F(x,y) = 0.

Cudd_SplitSet()                Returns m minterms from a BDD.

Cudd_Srandom()                 Initializer for the portable random number
                               generator.

Cudd_StdPostReordHook()        Sample hook function to call after reordering.

Cudd_StdPreReordHook()         Sample hook function to call before reordering.

Cudd_SubsetCompress()          Find a dense subset of BDD f.

Cudd_SubsetHeavyBranch()       Extracts a dense subset from a BDD with the
                               heavy branch heuristic.

Cudd_SubsetShortPaths()        Extracts a dense subset from a BDD with the
                               shortest paths heuristic.

Cudd_SupersetCompress()        Find a dense superset of BDD f.

Cudd_SupersetHeavyBranch()     Extracts a dense superset from a BDD with the
                               heavy branch heuristic.

Cudd_SupersetShortPaths()      Extracts a dense superset from a BDD with the
                               shortest paths heuristic.

Cudd_SupportSize()             Counts the variables on which a DD depends.

Cudd_Support()                 Finds the variables on which a DD depends.

Cudd_SymmProfile()             Prints statistics on symmetric variables.

Cudd_TurnOffCountDead()        Causes the dead nodes not to be counted towards
                               triggering reordering.

Cudd_TurnOnCountDead()         Causes the dead nodes to be counted towards
                               triggering reordering.

Cudd_T()                       Returns the then child of an internal node.

Cudd_UnderApprox()             Extracts a dense subset from a BDD with
                               Shiple's underapproximation method.

Cudd_VectorSupportSize()       Counts the variables on which a set of DDs
                               depends.

Cudd_VectorSupport()           Finds the variables on which a set of DDs
                               depends.

Cudd_VerifySol()               Checks the solution of F(x,y) = 0.

Cudd_V()                       Returns the value of a constant node.

Cudd_Xeqy()                    Generates a BDD for the function x==y.

Cudd_Xgty()                    Generates a BDD for the function x > y.

Cudd_addAgreement()            f if f==g; background if f!=g.

Cudd_addBddInterval()          Converts an ADD to a BDD.

Cudd_addBddIthBit()            Converts an ADD to a BDD by extracting the i-th
                               bit from the leaves.

Cudd_addBddPattern()           Converts an ADD to a BDD.

Cudd_addBddStrictThreshold()   Converts an ADD to a BDD.

Cudd_addBddThreshold()         Converts an ADD to a BDD.

Cudd_addCmpl()                 Computes the complement of an ADD a la C
                               language.

Cudd_addCompose()              Substitutes g for x_v in the ADD for f.

Cudd_addComputeCube()          Computes the cube of an array of ADD variables.

Cudd_addConstrain()            Computes f constrain c for ADDs.

Cudd_addConst()                Returns the ADD for constant c.

Cudd_addDiff()                 Returns plusinfinity if f=g; returns min(f,g)
                               if f!=g.

Cudd_addDivide()               Integer and floating point division.

Cudd_addEvalConst()            Checks whether ADD g is constant whenever ADD f
                               is 1.

Cudd_addExistAbstract()        Existentially Abstracts all the variables in
                               cube from f.

Cudd_addFindMax()              Finds the maximum discriminant of f.

Cudd_addFindMin()              Finds the minimum discriminant of f.

Cudd_addHamming()              Computes the Hamming distance ADD.

Cudd_addHarwell()              Reads in a matrix in the format of the Harwell-
                               Boeing benchmark suite.

Cudd_addIteConstant()          Implements ITEconstant for ADDs.

Cudd_addIte()                  Implements ITE(f,g,h).

Cudd_addIthBit()               Extracts the i-th bit from an ADD.

Cudd_addIthVar()               Returns the ADD variable with index i.

Cudd_addLeq()                  Determines whether f is less than or equal to
                               g.

Cudd_addMatrixMultiply()       Calculates the product of two matrices
                               represented as ADDs.

Cudd_addMaximum()              Integer and floating point max.

Cudd_addMinimum()              Integer and floating point min.

Cudd_addMinus()                Integer and floating point subtraction.

Cudd_addNand()                 NAND of two 0-1 ADDs.

Cudd_addNegate()               Computes the additive inverse of an ADD.

Cudd_addNewVarAtLevel()        Returns a new ADD variable at a specified
                               level.

Cudd_addNewVar()               Returns a new ADD variable.

Cudd_addNonSimCompose()        Composes an ADD with a vector of 0-1 ADDs.

Cudd_addNor()                  NOR of two 0-1 ADDs.

Cudd_addOneZeroMaximum()       Returns 1 if f &gt g and 0 otherwise.

Cudd_addOrAbstract()           Disjunctively abstracts all the variables in
                               cube from the 0-1 ADD f.

Cudd_addOr()                   Disjunction of two 0-1 ADDs.

Cudd_addPermute()              Permutes the variables of an ADD.

Cudd_addPlus()                 Integer and floating point addition.

Cudd_addRead()                 Reads in a sparse matrix.

Cudd_addResidue()              Builds an ADD for the residue modulo m of an n-
                               bit number.

Cudd_addRestrict()             ADD restrict according to Coudert and Madre's
                               algorithm (ICCAD90).

Cudd_addRoundOff()             Rounds off the discriminants of an ADD.

Cudd_addScalarInverse()        Computes the scalar inverse of an ADD.

Cudd_addSetNZ()                This operator sets f to the value of g wherever
                               g != 0.

Cudd_addSwapVariables()        Swaps two sets of variables of the same size (x
                               and y) in the ADD f.

Cudd_addThreshold()            f if f>=g; 0 if f<g.

Cudd_addTimesPlus()            Calculates the product of two matrices
                               represented as ADDs.

Cudd_addTimes()                Integer and floating point multiplication.

Cudd_addTriangle()             Performs the triangulation step for the
                               shortest path computation.

Cudd_addUnivAbstract()         Universally Abstracts all the variables in cube
                               from f.

Cudd_addVectorCompose()        Composes an ADD with a vector of 0-1 ADDs.

Cudd_addWalsh()                Generates a Walsh matrix in ADD form.

Cudd_addXeqy()                 Generates an ADD for the function x==y.

Cudd_addXnor()                 XNOR of two 0-1 ADDs.

Cudd_addXor()                  XOR of two 0-1 ADDs.

Cudd_bddAdjPermuteX()          Rearranges a set of variables in the BDD B.

Cudd_bddAndAbstract()          Takes the AND of two BDDs and simultaneously
                               abstracts the variables in cube.

Cudd_bddAnd()                  Computes the conjunction of two BDDs f and g.

Cudd_bddApproxConjDecomp()     Performs two-way conjunctive decomposition of a
                               BDD.

Cudd_bddApproxDisjDecomp()     Performs two-way disjunctive decomposition of a
                               BDD.

Cudd_bddBooleanDiff()          Computes the boolean difference of f with
                               respect to x.

Cudd_bddCharToVect()           Computes a vector whose image equals a non-zero
                               function.

Cudd_bddClippingAndAbstract()  Approximates the conjunction of two BDDs f and
                               g and simultaneously abstracts the variables in
                               cube.

Cudd_bddClippingAnd()          Approximates the conjunction of two BDDs f and
                               g.

Cudd_bddCompose()              Substitutes g for x_v in the BDD for f.

Cudd_bddComputeCube()          Computes the cube of an array of BDD variables.

Cudd_bddConstrainDecomp()      BDD conjunctive decomposition as in McMillan's
                               CAV96 paper.

Cudd_bddConstrain()            Computes f constrain c.

Cudd_bddCorrelationWeights()   Computes the correlation of f and g for given
                               input probabilities.

Cudd_bddCorrelation()          Computes the correlation of f and g.

Cudd_bddExistAbstract()        Existentially abstracts all the variables in
                               cube from f.

Cudd_bddGenConjDecomp()        Performs two-way conjunctive decomposition of a
                               BDD.

Cudd_bddGenDisjDecomp()        Performs two-way disjunctive decomposition of a
                               BDD.

Cudd_bddIntersect()            Returns a function included in the intersection
                               of f and g.

Cudd_bddIsVarEssential()       Determines whether a given variable is
                               essential with a given phase in a BDD.

Cudd_bddIsop()                 Computes a BDD in the interval between L and U
                               with a simple sum-of-produuct cover.

Cudd_bddIteConstant()          Implements ITEconstant(f,g,h).

Cudd_bddIterConjDecomp()       Performs two-way conjunctive decomposition of a
                               BDD.

Cudd_bddIterDisjDecomp()       Performs two-way disjunctive decomposition of a
                               BDD.

Cudd_bddIte()                  Implements ITE(f,g,h).

Cudd_bddIthVar()               Returns the BDD variable with index i.

Cudd_bddLICompaction()         Performs safe minimization of a BDD.

Cudd_bddLeq()                  Determines whether f is less than or equal to
                               g.

Cudd_bddLiteralSetIntersection()
                               Computes the intesection of two sets of
                               literals represented as BDDs.

Cudd_bddMinimize()             Finds a small BDD that agrees with
                               f over c.

Cudd_bddNand()                 Computes the NAND of two BDDs f and g.

Cudd_bddNewVarAtLevel()        Returns a new BDD variable at a specified
                               level.

Cudd_bddNewVar()               Returns a new BDD variable.

Cudd_bddNor()                  Computes the NOR of two BDDs f and g.

Cudd_bddOr()                   Computes the disjunction of two BDDs f and g.

Cudd_bddPermute()              Permutes the variables of a BDD.

Cudd_bddPickArbitraryMinterms()
                               Picks k on-set minterms evenly distributed from
                               given DD.

Cudd_bddPickOneCube()          Picks one on-set cube randomly from the given
                               DD.

Cudd_bddPickOneMinterm()       Picks one on-set minterm randomly from the
                               given DD.

Cudd_bddRead()                 Reads in a graph (without labels) given as a
                               list of arcs.

Cudd_bddRealignDisable()       Disables realignment of ZDD order to BDD order.

Cudd_bddRealignEnable()        Enables realignment of BDD order to ZDD order.

Cudd_bddRealignmentEnabled()   Tells whether the realignment of BDD order to
                               ZDD order is enabled.

Cudd_bddRestrict()             BDD restrict according to Coudert and Madre's
                               algorithm (ICCAD90).

Cudd_bddSqueeze()              Finds a small BDD in a function interval.

Cudd_bddSwapVariables()        Swaps two sets of variables of the same size (x
                               and y) in the BDD f.

Cudd_bddTransfer()             Convert a BDD from a manager to another one.

Cudd_bddUnivAbstract()         Universally abstracts all the variables in cube
                               from f.

Cudd_bddVarConjDecomp()        Performs two-way conjunctive decomposition of a
                               BDD.

Cudd_bddVarDisjDecomp()        Performs two-way disjunctive decomposition of a
                               BDD.

Cudd_bddVarIsDependent()       Checks whether a variable is dependent on
                               others in a function.

Cudd_bddVarMap()               Remaps the variables of a BDD using the default
                               variable map.

Cudd_bddVectorCompose()        Composes a BDD with a vector of BDDs.

Cudd_bddXnor()                 Computes the exclusive NOR of two BDDs f and g.

Cudd_bddXorExistAbstract()     Takes the exclusive OR of two BDDs and
                               simultaneously abstracts the variables in cube.

Cudd_bddXor()                  Computes the exclusive OR of two BDDs f and g.

Cudd_zddChange()               Substitutes a variable with its complement in a
                               ZDD.

Cudd_zddComplement()           Computes a complement cover for a ZDD node.

Cudd_zddCountDouble()          Counts the number of minterms of a ZDD.

Cudd_zddCountMinterm()         Counts the number of minterms of a ZDD.

Cudd_zddCount()                Counts the number of minterms in a ZDD.

Cudd_zddDagSize()              Counts the number of nodes in a ZDD.

Cudd_zddDiffConst()            Performs the inclusion test for ZDDs (P implies
                               Q).

Cudd_zddDiff()                 Computes the difference of two ZDDs.

Cudd_zddDivideF()              Modified version of Cudd_zddDivide.

Cudd_zddDivide()               Computes the quotient of two unate covers.

Cudd_zddDumpDot()              Writes a dot file representing the argument
                               ZDDs.

Cudd_zddIntersect()            Computes the intersection of two ZDDs.

Cudd_zddIsop()                 Computes an ISOP in ZDD form from BDDs.

Cudd_zddIte()                  Computes the ITE of three ZDDs.

Cudd_zddIthVar()               Returns the ZDD variable with index i.

Cudd_zddPortFromBdd()          Converts a BDD into a ZDD.

Cudd_zddPortToBdd()            Converts a ZDD into a BDD.

Cudd_zddPrintCover()           Prints a sum of products from a ZDD
                               representing a cover.

Cudd_zddPrintDebug()           Prints to the standard output a ZDD and its
                               statistics.

Cudd_zddPrintMinterm()         Prints a disjoint sum of product form for a
                               ZDD.

Cudd_zddPrintSubtable()        Prints the ZDD table.

Cudd_zddProduct()              Computes the product of two covers represented
                               by ZDDs.

Cudd_zddReadNodeCount()        Reports the number of nodes in ZDDs.

Cudd_zddRealignDisable()       Disables realignment of ZDD order to BDD order.

Cudd_zddRealignEnable()        Enables realignment of ZDD order to BDD order.

Cudd_zddRealignmentEnabled()   Tells whether the realignment of ZDD order to
                               BDD order is enabled.

Cudd_zddReduceHeap()           Main dynamic reordering routine for ZDDs.

Cudd_zddShuffleHeap()          Reorders ZDD variables according to given
                               permutation.

Cudd_zddSubset0()              Computes the negative cofactor of a ZDD w.r.t.
                               a variable.

Cudd_zddSubset1()              Computes the positive cofactor of a ZDD w.r.t.
                               a variable.

Cudd_zddSymmProfile()          Prints statistics on symmetric ZDD variables.

Cudd_zddUnateProduct()         Computes the product of two unate covers.

Cudd_zddUnion()                Computes the union of two ZDDs.

Cudd_zddVarsFromBddVars()      Creates one or more ZDD variables for each BDD
                               variable.

Cudd_zddWeakDivF()             Modified version of Cudd_zddWeakDiv.

Cudd_zddWeakDiv()              Applies weak division to two covers.

**********************************************************************

External functions and data strucures of the CUDD package.       To
turn on the gathering of statistics, define DD_STATS.    To link with
mis, define DD_MIS.      Modified by Abelardo Pardo to interface it to
VIS.

DdApaDigit
Cudd_ApaAdd(
  int               digits,
  DdApaNumber       a,
  DdApaNumber       b,
  DdApaNumber       sum
)
  Adds two arbitrary precision integers. Returns the carry out of the most
  significant digit.

  Side Effects: The result of the sum is stored in parameter sum.

int
Cudd_ApaCompareRatios(
  int               digitsFirst,
  DdApaNumber       firstNum,
  unsigned int      firstDen,
  int               digitsSecond,
  DdApaNumber       secondNum,
  unsigned int      secondDen
)
  Compares the ratios of two arbitrary precision integers to two unsigned
  ints. Returns 1 if the first number is larger; 0 if they are equal; -1 if
  the second number is larger.

  Side Effects: None

int
Cudd_ApaCompare(
  int               digitsFirst,
  DdApaNumber       first,
  int               digitsSecond,
  DdApaNumber       second
)
  Compares two arbitrary precision integers. Returns 1 if the first number is
  larger; 0 if they are equal; -1 if the second number is larger.

  Side Effects: None

void
Cudd_ApaCopy(
  int               digits,
  DdApaNumber       source,
  DdApaNumber       dest
)
  Makes a copy of an arbitrary precision integer.

  Side Effects: Changes parameter dest.

DdApaNumber
Cudd_ApaCountMinterm(
  DdManager *       manager,
  DdNode *          node,
  int               nvars,
  int *             digits
)
  Counts the number of minterms of a DD. The function is assumed to depend on
  nvars variables. The minterm count is represented as an arbitrary precision
  unsigned integer, to allow for any number of variables CUDD supports.
  Returns a pointer to the array representing the number of minterms of the
  function rooted at node if successful; NULL otherwise.

  Side Effects: The number of digits of the result is returned in parameter
  digits.

unsigned int
Cudd_ApaIntDivision(
  int               digits,
  DdApaNumber       dividend,
  unsigned int      divisor,
  DdApaNumber       quotient
)
  Divides an arbitrary precision integer by a 32-bit unsigned integer. Returns
  the remainder of the division. This procedure relies on the assumption that
  the number of bits of a DdApaDigit plus the number of bits of an unsigned
  int is less the number of bits of the mantissa of a double. This guarantees
  that the product of a DdApaDigit and an unsigned int can be represented
  without loss of precision by a double. On machines where this assumption is
  not satisfied, this procedure will malfunction.

  Side Effects: The quotient is returned in parameter quotient.

int
Cudd_ApaNumberOfDigits(
  int               binaryDigits
)
  Finds the number of digits for an arbitrary precision integer given the
  maximum number of binary digits. The number of binary digits should be
  positive. Returns the number of digits if successful; 0 otherwise.

  Side Effects: None

void
Cudd_ApaPowerOfTwo(
  int               digits,
  DdApaNumber       number,
  int               power
)
  Sets an arbitrary precision integer to a power of two. If the power of two
  is too large to be represented, the number is set to 0.

  Side Effects: The result is returned in parameter number.

int
Cudd_ApaPrintDecimal(
  FILE *            fp,
  int               digits,
  DdApaNumber       number
)
  Prints an arbitrary precision integer in decimal format. Returns 1 if
  successful; 0 otherwise.

  Side Effects: None

int
Cudd_ApaPrintDensity(
  FILE *            fp,
  DdManager *       dd,
  DdNode *          node,
  int               nvars
)
  Prints the density of a BDD or ADD using arbitrary precision arithmetic.
  Returns 1 if successful; 0 otherwise.

  Side Effects: None

int
Cudd_ApaPrintExponential(
  FILE *            fp,
  int               digits,
  DdApaNumber       number,
  int               precision
)
  Prints an arbitrary precision integer in exponential format. Returns 1 if
  successful; 0 otherwise.

  Side Effects: None

int
Cudd_ApaPrintHex(
  FILE *            fp,
  int               digits,
  DdApaNumber       number
)
  Prints an arbitrary precision integer in hexadecimal format. Returns 1 if
  successful; 0 otherwise.

  Side Effects: None

int
Cudd_ApaPrintMintermExp(
  FILE *            fp,
  DdManager *       dd,
  DdNode *          node,
  int               nvars,
  int               precision
)
  Prints the number of minterms of a BDD or ADD in exponential format using
  arbitrary precision arithmetic. Parameter precision controls the number of
  signficant digits printed. Returns 1 if successful; 0 otherwise.

  Side Effects: None

int
Cudd_ApaPrintMinterm(
  FILE *            fp,
  DdManager *       dd,
  DdNode *          node,
  int               nvars
)
  Prints the number of minterms of a BDD or ADD using arbitrary precision
  arithmetic. Returns 1 if successful; 0 otherwise.

  Side Effects: None

void
Cudd_ApaSetToLiteral(
  int               digits,
  DdApaNumber       number,
  DdApaDigit        literal
)
  Sets an arbitrary precision integer to a one-digit literal.

  Side Effects: The result is returned in parameter number.

void
Cudd_ApaShiftRight(
  int               digits,
  DdApaDigit        in,
  DdApaNumber       a,
  DdApaNumber       b
)
  Shifts right an arbitrary precision integer by one binary place. The most
  significant binary digit of the result is taken from parameter
  in.

  Side Effects: The result is returned in parameter b.

DdApaDigit
Cudd_ApaShortDivision(
  int               digits,
  DdApaNumber       dividend,
  DdApaDigit        divisor,
  DdApaNumber       quotient
)
  Divides an arbitrary precision integer by a digit.

  Side Effects: The quotient is returned in parameter quotient.

DdApaDigit
Cudd_ApaSubtract(
  int               digits,
  DdApaNumber       a,
  DdApaNumber       b,
  DdApaNumber       diff
)
  Subtracts two arbitrary precision integers. Returns the borrow out of the
  most significant digit.

  Side Effects: The result of the subtraction is stored in parameter
  diff.

void
Cudd_AutodynDisableZdd(
  DdManager *       unique
)
  Disables automatic dynamic reordering of ZDDs.

  Side Effects: None

void
Cudd_AutodynDisable(
  DdManager *       unique
)
  Disables automatic dynamic reordering.

  Side Effects: None

void
Cudd_AutodynEnableZdd(
  DdManager *       unique,
  Cudd_ReorderingTy method
)
  Enables automatic dynamic reordering of ZDDs. Parameter method is used to
  determine the method used for reordering ZDDs. If CUDD_REORDER_SAME is
  passed, the method is unchanged.

  Side Effects: None

void
Cudd_AutodynEnable(
  DdManager *       unique,
  Cudd_ReorderingTy method
)
  Enables automatic dynamic reordering of BDDs and ADDs. Parameter method is
  used to determine the method used for reordering. If CUDD_REORDER_SAME is
  passed, the method is unchanged.

  Side Effects: None

double
Cudd_AverageDistance(
  DdManager *       dd
)
  Computes the average distance between adjacent nodes in the manager.
  Adjacent nodes are node pairs such that the second node is the then child,
  else child, or next node in the collision list.

  Side Effects: None

DdNode *
Cudd_BddToAdd(
  DdManager *       dd,
  DdNode *          B
)
  Converts a BDD to a 0-1 ADD. Returns a pointer to the resulting ADD if
  successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_BiasedOverApprox(
  DdManager *       dd,              manager
  DdNode *          f,               function to be superset
  DdNode *          b,               bias function
  int               numVars,         number of variables in the support of f
  int               threshold,       when to stop approximation
  double            quality1,        minimum improvement for accepted changes
                                     when b=1
  double            quality0         minimum improvement for accepted changes
                                     when b=0
)
  Extracts a dense superset from a BDD. The procedure is identical to the
  underapproximation procedure except for the fact that it works on the
  complement of the given function. Extracting the subset of the complement
  function is equivalent to extracting the superset of the function. Returns a
  pointer to the BDD of the superset if successful. NULL if intermediate
  result causes the procedure to run out of memory. The parameter numVars is
  the maximum number of variables to be used in minterm calculation. The
  optimal number should be as close as possible to the size of the support of
  f. However, it is safe to pass the value returned by Cudd_ReadSize for
  numVars when the number of variables is under 1023. If numVars is larger
  than 1023, it will overflow. If a 0 parameter is passed then the procedure
  will compute a value which will avoid overflow but will cause underflow with
  2046 variables or more.

  Side Effects: None

DdNode *
Cudd_BiasedUnderApprox(
  DdManager *       dd,              manager
  DdNode *          f,               function to be subset
  DdNode *          b,               bias function
  int               numVars,         number of variables in the support of f
  int               threshold,       when to stop approximation
  double            quality1,        minimum improvement for accepted changes
                                     when b=1
  double            quality0         minimum improvement for accepted changes
                                     when b=0
)
  Extracts a dense subset from a BDD. This procedure uses a biased remapping
  technique and density as the cost function. The bias is a function. This
  procedure tries to approximate wherer the bias is 0 and preserve the given
  function where the bias is 1. Returns a pointer to the BDD of the subset if
  successful. NULL if the procedure runs out of memory. The parameter numVars
  is the maximum number of variables to be used in minterm calculation. The
  optimal number should be as close as possible to the size of the support of
  f. However, it is safe to pass the value returned by Cudd_ReadSize for
  numVars when the number of variables is under 1023. If numVars is larger
  than 1023, it will cause overflow. If a 0 parameter is passed then the
  procedure will compute a value which will avoid overflow but will cause
  underflow with 2046 variables or more.

  Side Effects: None

DdNode *
Cudd_CProjection(
  DdManager *       dd,
  DdNode *          R,
  DdNode *          Y
)
  Computes the compatible projection of relation R with respect to cube Y.
  Returns a pointer to the c-projection if successful; NULL otherwise. For a
  comparison between Cudd_CProjection and Cudd_PrioritySelect, see the
  documentation of the latter.

  Side Effects: None

int
Cudd_CheckKeys(
  DdManager *       table
)
  Checks for the following conditions:  Wrong sizes of subtables.
  Wrong number of keys found in unique subtable. Wrong number of dead
  found in unique subtable. Wrong number of keys found in the constant
  table Wrong number of dead found in the constant table Wrong number
  of total slots found Wrong number of maximum keys found Wrong number
  of total dead found  Reports the average length of non-empty lists.
  Returns the number of subtables for which the number of keys is wrong.

  Side Effects: None

int
Cudd_CheckZeroRef(
  DdManager *       manager
)
  Checks the unique table for nodes with non-zero reference counts. It is
  normally called before Cudd_Quit to make sure that there are no memory leaks
  due to missing Cudd_RecursiveDeref's. Takes into account that reference
  counts may saturate and that the basic constants and the projection
  functions are referenced by the manager. Returns the number of nodes with
  non-zero reference count. (Except for the cases mentioned above.)

  Side Effects: None

int
Cudd_ClassifySupport(
  DdManager *       dd,              manager
  DdNode *          f,               first DD
  DdNode *          g,               second DD
  DdNode **         common,          cube of shared variables
  DdNode **         onlyF,           cube of variables only in f
  DdNode **         onlyG            cube of variables only in g
)
  Classifies the variables in the support of two DDs f and
  g, depending on whther they appear in both DDs, only in
  f, or only in g. Returns 1 successful; 0
  otherwise.

  Side Effects: The cubes of the three classes of variables are returned as
  side effects.

void
Cudd_ClearErrorCode(
  DdManager *       dd
)
  Clear the error code of a manager.

  Side Effects: None

double *
Cudd_CofMinterm(
  DdManager *       dd,
  DdNode *          node
)
  Computes the fraction of minterms in the on-set of all the positive
  cofactors of DD. Returns the pointer to an array of doubles if successful;
  NULL otherwise. The array hs as many positions as there are BDD variables in
  the manager plus one. The last position of the array contains the fraction
  of the minterms in the ON-set of the function represented by the BDD or ADD.
  The other positions of the array hold the variable signatures.

  Side Effects: None

DdNode *
Cudd_Cofactor(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Computes the cofactor of f with respect to g; g must be the BDD or the ADD
  of a cube. Returns a pointer to the cofactor if successful; NULL otherwise.

  Side Effects: None


Cudd_Complement(
                    node
)
  Returns the complemented version of a pointer.

  Side Effects: none

int
Cudd_CountLeaves(
  DdNode *          node
)
  Counts the number of leaves in a DD. Returns the number of leaves in the DD
  rooted at node if successful; CUDD_OUT_OF_MEM otherwise.

  Side Effects: None

double
Cudd_CountMinterm(
  DdManager *       manager,
  DdNode *          node,
  int               nvars
)
  Counts the number of minterms of a DD. The function is assumed to depend on
  nvars variables. The minterm count is represented as a double, to allow for
  a larger number of variables. Returns the number of minterms of the function
  rooted at node if successful; (double) CUDD_OUT_OF_MEM otherwise.

  Side Effects: None

double
Cudd_CountPath(
  DdNode *          node
)
  Counts the number of paths of a DD. Paths to all terminal nodes are counted.
  The path count is represented as a double, to allow for a larger number of
  variables. Returns the number of paths of the function rooted at node.

  Side Effects: None

int
Cudd_DagSize(
  DdNode *          node
)
  Counts the number of nodes in a DD. Returns the number of nodes in the graph
  rooted at node.

  Side Effects: None

int
Cudd_DeadAreCounted(
  DdManager *       dd
)
  Tells whether dead nodes are counted towards triggering reordering. Returns
  1 if dead nodes are counted; 0 otherwise.

  Side Effects: None

int
Cudd_DebugCheck(
  DdManager *       table
)
  Checks for inconsistencies in the DD heap:   node has illegal index
   live node has dead children  node has illegal Then or Else pointers
   BDD/ADD node has identical children  ZDD node has zero then child
   wrong number of total nodes  wrong number of dead nodes  ref
  count error at node  Returns 0 if no inconsistencies are found;
  DD_OUT_OF_MEM if there is not enough memory; 1 otherwise.

  Side Effects: None

DdNode *
Cudd_Decreasing(
  DdManager *       dd,
  DdNode *          f,
  int               i
)
  Determines whether the function represented by BDD f is negative unate
  (monotonic decreasing) in variable i. Returns the constant one is f is unate
  and the (logical) constant zero if it is not. This function does not
  generate any new nodes.

  Side Effects: None

void
Cudd_DelayedDerefBdd(
  DdManager *       table,
  DdNode *          n
)
  Enqueues node n for later dereferencing. If the queue is full decreases the
  reference count of the oldest node N to make room for n. If N dies,
  recursively decreases the reference counts of its children. It is used to
  dispose of a BDD that is currently not needed, but may be useful again in
  the near future. The dereferencing proper is done as in Cudd_IterDerefBdd.

  Side Effects: None

double
Cudd_Density(
  DdManager *       dd,              manager
  DdNode *          f,               function whose density is sought
  int               nvars            size of the support of f
)
  Computes the density of a BDD or ADD. The density is the ratio of the number
  of minterms to the number of nodes. If 0 is passed as number of variables,
  the number of variables existing in the manager is used. Returns the density
  if successful; (double) CUDD_OUT_OF_MEM otherwise.

  Side Effects: None

void
Cudd_Deref(
  DdNode *          node
)
  Decreases the reference count of node. It is primarily used in recursive
  procedures to decrease the ref count of a result node before returning it.
  This accomplishes the goal of removing the protection applied by a previous
  Cudd_Ref.

  Side Effects: None

void
Cudd_DisableGarbageCollection(
  DdManager *       dd
)
  Disables garbage collection. Garbage collection is initially enabled. This
  function may be called to disable it. However, garbage collection will still
  occur when a new node must be created and no memory is left, or when garbage
  collection is required for correctness. (E.g., before reordering.)

  Side Effects: None

int
Cudd_DisableReorderingReporting(
  DdManager *       dd
)
  Disables reporting of reordering stats. Returns 1 if successful; 0
  otherwise.

  Side Effects: Removes functions from the pre-reordering and post-reordering
  hooks.

int
Cudd_DumpBlif(
  DdManager *       dd,              manager
  int               n,               number of output nodes to be dumped
  DdNode **         f,               array of output nodes to be dumped
  char **           inames,          array of input names (or NULL)
  char **           onames,          array of output names (or NULL)
  char *            mname,           model name (or NULL)
  FILE *            fp               pointer to the dump file
)
  Writes a blif file representing the argument BDDs as a network of
  multiplexers. One multiplexer is written for each BDD node. It returns 1 in
  case of success; 0 otherwise (e.g., out-of-memory, file system full, or an
  ADD with constants different from 0 and 1). Cudd_DumpBlif does not close the
  file: This is the caller responsibility. Cudd_DumpBlif uses a minimal unique
  subset of the hexadecimal address of a node as name for it. If the argument
  inames is non-null, it is assumed to hold the pointers to the names of the
  inputs. Similarly for onames.

  Side Effects: None

int
Cudd_DumpDDcal(
  DdManager *       dd,              manager
  int               n,               number of output nodes to be dumped
  DdNode **         f,               array of output nodes to be dumped
  char **           inames,          array of input names (or NULL)
  char **           onames,          array of output names (or NULL)
  FILE *            fp               pointer to the dump file
)
  Writes a DDcal file representing the argument BDDs. It returns 1 in case of
  success; 0 otherwise (e.g., out-of-memory or file system full).
  Cudd_DumpDDcal does not close the file: This is the caller responsibility.
  Cudd_DumpDDcal uses a minimal unique subset of the hexadecimal address of a
  node as name for it. If the argument inames is non-null, it is assumed to
  hold the pointers to the names of the inputs. Similarly for onames.

  Side Effects: None

int
Cudd_DumpDaVinci(
  DdManager *       dd,              manager
  int               n,               number of output nodes to be dumped
  DdNode **         f,               array of output nodes to be dumped
  char **           inames,          array of input names (or NULL)
  char **           onames,          array of output names (or NULL)
  FILE *            fp               pointer to the dump file
)
  Writes a daVinci file representing the argument BDDs. It returns 1 in case
  of success; 0 otherwise (e.g., out-of-memory or file system full).
  Cudd_DumpDaVinci does not close the file: This is the caller responsibility.
  Cudd_DumpDaVinci uses a minimal unique subset of the hexadecimal address of
  a node as name for it. If the argument inames is non-null, it is assumed to
  hold the pointers to the names of the inputs. Similarly for onames.

  Side Effects: None

int
Cudd_DumpDot(
  DdManager *       dd,              manager
  int               n,               number of output nodes to be dumped
  DdNode **         f,               array of output nodes to be dumped
  char **           inames,          array of input names (or NULL)
  char **           onames,          array of output names (or NULL)
  FILE *            fp               pointer to the dump file
)
  Writes a file representing the argument DDs in a format suitable for the
  graph drawing program dot. It returns 1 in case of success; 0 otherwise
  (e.g., out-of-memory, file system full). Cudd_DumpDot does not close the
  file: This is the caller responsibility. Cudd_DumpDot uses a minimal unique
  subset of the hexadecimal address of a node as name for it. If the argument
  inames is non-null, it is assumed to hold the pointers to the names of the
  inputs. Similarly for onames. Cudd_DumpDot uses the following convention to
  draw arcs:   solid line: THEN arcs;  dotted line: complement
  arcs;  dashed line: regular ELSE arcs.  The dot options are chosen
  so that the drawing fits on a letter-size sheet.

  Side Effects: None

int
Cudd_DumpFactoredForm(
  DdManager *       dd,              manager
  int               n,               number of output nodes to be dumped
  DdNode **         f,               array of output nodes to be dumped
  char **           inames,          array of input names (or NULL)
  char **           onames,          array of output names (or NULL)
  FILE *            fp               pointer to the dump file
)
  Writes factored forms representing the argument BDDs. The format of the
  factored form is the one used in the genlib files for technology mapping in
  sis. It returns 1 in case of success; 0 otherwise (e.g., file system full).
  Cudd_DumpFactoredForm does not close the file: This is the caller
  responsibility. Caution must be exercised because a factored form may be
  exponentially larger than the argument BDD. If the argument inames is non-
  null, it is assumed to hold the pointers to the names of the inputs.
  Similarly for onames.

  Side Effects: None

DdNode *
Cudd_Dxygtdxz(
  DdManager *       dd,              DD manager
  int               N,               number of x, y, and z variables
  DdNode **         x,               array of x variables
  DdNode **         y,               array of y variables
  DdNode **         z                array of z variables
)
  This function generates a BDD for the function d(x,y) > d(x,z); x, y, and
  z are N-bit numbers, x[0] x[1] ... x[N-1], y[0] y[1] ... y[N-1], and z[0]
  z[1] ... z[N-1], with 0 the most significant bit. The distance d(x,y) is
  defined as: sum_{i=0}^{N-1}(|x_i - y_i| cdot 2^{N-i-1}). The BDD is built
  bottom-up. It has 7*N-3 internal nodes, if the variables are ordered as
  follows: x[0] y[0] z[0] x[1] y[1] z[1] ... x[N-1] y[N-1] z[N-1].

  Side Effects: None

DdNode *
Cudd_Dxygtdyz(
  DdManager *       dd,              DD manager
  int               N,               number of x, y, and z variables
  DdNode **         x,               array of x variables
  DdNode **         y,               array of y variables
  DdNode **         z                array of z variables
)
  This function generates a BDD for the function d(x,y) > d(y,z); x, y, and
  z are N-bit numbers, x[0] x[1] ... x[N-1], y[0] y[1] ... y[N-1], and z[0]
  z[1] ... z[N-1], with 0 the most significant bit. The distance d(x,y) is
  defined as: sum_{i=0}^{N-1}(|x_i - y_i| cdot 2^{N-i-1}). The BDD is built
  bottom-up. It has 7*N-3 internal nodes, if the variables are ordered as
  follows: x[0] y[0] z[0] x[1] y[1] z[1] ... x[N-1] y[N-1] z[N-1].

  Side Effects: None

void
Cudd_EnableGarbageCollection(
  DdManager *       dd
)
  Enables garbage collection. Garbage collection is initially enabled.
  Therefore it is necessary to call this function only if garbage collection
  has been explicitly disabled.

  Side Effects: None

int
Cudd_EnableReorderingReporting(
  DdManager *       dd
)
  Enables reporting of reordering stats. Returns 1 if successful; 0 otherwise.

  Side Effects: Installs functions in the pre-reordering and post-reordering
  hooks.

int
Cudd_EqualSupNorm(
  DdManager *       dd,              manager
  DdNode *          f,               first ADD
  DdNode *          g,               second ADD
  CUDD_VALUE_TYPE   tolerance,       maximum allowed difference
  int               pr               verbosity level
)
  Compares two ADDs for equality within tolerance. Two ADDs are reported to be
  equal if the maximum difference between them (the sup norm of their
  difference) is less than or equal to the tolerance parameter. Returns 1 if
  the two ADDs are equal (within tolerance); 0 otherwise. If parameter
  pr is positive the first failure is reported to the standard
  output.

  Side Effects: None

int
Cudd_EquivDC(
  DdManager *       dd,
  DdNode *          F,
  DdNode *          G,
  DdNode *          D
)
  Tells whether F and G are identical wherever D is 0. F and G are either two
  ADDs or two BDDs. D is either a 0-1 ADD or a BDD. The function returns 1 if
  F and G are equivalent, and 0 otherwise. No new nodes are created.

  Side Effects: None

int
Cudd_EstimateCofactorSimple(
  DdNode *          node,
  int               i
)
  Estimates the number of nodes in a cofactor of a DD. Returns an estimate of
  the number of nodes in the positive cofactor of the graph rooted at node
  with respect to the variable whose index is i. This procedure implements
  with minor changes the algorithm of Cabodi et al. (ICCAD96). It does not
  allocate any memory, it does not change the state of the manager, and it is
  fast. However, it has been observed to overestimate the size of the cofactor
  by as much as a factor of 2.

  Side Effects: None

int
Cudd_EstimateCofactor(
  DdManager *       dd,
  DdNode *          f,
  int               i,
  int               phase            1: positive; 0: negative
)
  Estimates the number of nodes in a cofactor of a DD. Returns an estimate of
  the number of nodes in a cofactor of the graph rooted at node with respect
  to the variable whose index is i. In case of failure, returns
  CUDD_OUT_OF_MEM. This function uses a refinement of the algorithm of Cabodi
  et al. (ICCAD96). The refinement allows the procedure to account for part of
  the recombination that may occur in the part of the cofactor above the
  cofactoring variable. This procedure does no create any new node. It does
  keep a small table of results; therefore itmay run out of memory. If this is
  a concern, one should use Cudd_EstimateCofactorSimple, which is faster, does
  not allocate any memory, but is less accurate.

  Side Effects: None

DdNode *
Cudd_Eval(
  DdManager *       dd,
  DdNode *          f,
  int *             inputs
)
  Finds the value of a DD for a given variable assignment. The variable
  assignment is passed in an array of int's, that should specify a zero or a
  one for each variable in the support of the function. Returns a pointer to a
  constant node. No new nodes are produced.

  Side Effects: None

double
Cudd_ExpectedUsedSlots(
  DdManager *       dd
)
  Computes the fraction of slots in the unique table that should be in use.
  This expected value is based on the assumption that the hash function
  distributes the keys randomly; it can be compared with the result of
  Cudd_ReadUsedSlots to monitor the performance of the unique table hash
  function.

  Side Effects: None


Cudd_E(
                    node
)
  Returns the else child of an internal node. If node is a
  constant node, the result is unpredictable.

  Side Effects: none

DdNode *
Cudd_FindEssential(
  DdManager *       dd,
  DdNode *          f
)
  Returns the cube of the essential variables. A positive literal means that
  the variable must be set to 1 for the function to be 1. A negative literal
  means that the variable must be set to 0 for the function to be 1. Returns a
  pointer to the cube BDD if successful; NULL otherwise.

  Side Effects: None

DdGen *
Cudd_FirstCube(
  DdManager *       dd,
  DdNode *          f,
  int **            cube,
  CUDD_VALUE_TYPE * value
)
  Defines an iterator on the onset of a decision diagram and finds its first
  cube. Returns a generator that contains the information necessary to
  continue the enumeration if successful; NULL otherwise. A cube is
  represented as an array of literals, which are integers in {0, 1, 2}; 0
  represents a complemented literal, 1 represents an uncomplemented literal,
  and 2 stands for don't care. The enumeration produces a disjoint cover of
  the function associated with the diagram. The size of the array equals the
  number of variables in the manager at the time Cudd_FirstCube is called.
  For each cube, a value is also returned. This value is always 1 for a BDD,
  while it may be different from 1 for an ADD. For BDDs, the offset is the set
  of cubes whose value is the logical zero. For ADDs, the offset is the set of
  cubes whose value is the background value. The cubes of the offset are not
  enumerated.

  Side Effects: The first cube and its value are returned as side effects.

DdGen *
Cudd_FirstNode(
  DdManager *       dd,
  DdNode *          f,
  DdNode **         node
)
  Defines an iterator on the nodes of a decision diagram and finds its first
  node. Returns a generator that contains the information necessary to
  continue the enumeration if successful; NULL otherwise.

  Side Effects: The first node is returned as a side effect.


Cudd_ForeachCube(
                    manager,
                    f,
                    gen,
                    cube,
                    value
)
  Iterates over the cubes of a decision diagram f.   DdManager
  *manager;  DdNode *f;  DdGen *gen;  int **cube; 
  CUDD_VALUE_TYPE *value;  Cudd_ForeachCube allocates and frees the
  generator. Therefore the application should not try to do that. Also, the
  cube is freed at the end of Cudd_ForeachCube and hence is not available
  outside of the loop. CAUTION: It is assumed that dynamic reordering will
  not occur while there are open generators. It is the user's responsibility
  to make sure that dynamic reordering does not occur. As long as new nodes
  are not created during generation, and dynamic reordering is not called
  explicitly, dynamic reordering will not occur. Alternatively, it is
  sufficient to disable dynamic reordering. It is a mistake to dispose of a
  diagram on which generation is ongoing.

  Side Effects: none


Cudd_ForeachNode(
                    manager,
                    f,
                    gen,
                    node
)
  Iterates over the nodes of a decision diagram f.   DdManager
  *manager;  DdNode *f;  DdGen *gen;  DdNode **node;  The
  nodes are returned in a seemingly random order. Cudd_ForeachNode allocates
  and frees the generator. Therefore the application should not try to do
  that. CAUTION: It is assumed that dynamic reordering will not occur while
  there are open generators. It is the user's responsibility to make sure that
  dynamic reordering does not occur. As long as new nodes are not created
  during generation, and dynamic reordering is not called explicitly, dynamic
  reordering will not occur. Alternatively, it is sufficient to disable
  dynamic reordering. It is a mistake to dispose of a diagram on which
  generation is ongoing.

  Side Effects: none

void
Cudd_FreeTree(
  DdManager *       dd
)
  Frees the variable group tree of the manager.

  Side Effects: None

void
Cudd_FreeZddTree(
  DdManager *       dd
)
  Frees the variable group tree of the manager.

  Side Effects: None

int
Cudd_GarbageCollectionEnabled(
  DdManager *       dd
)
  Returns 1 if garbage collection is enabled; 0 otherwise.

  Side Effects: None

int
Cudd_GenFree(
  DdGen *           gen
)
  Frees a CUDD generator. Always returns 0, so that it can be used in mis-like
  foreach constructs.

  Side Effects: None

DdNode *
Cudd_Increasing(
  DdManager *       dd,
  DdNode *          f,
  int               i
)
  Determines whether the function represented by BDD f is positive unate
  (monotonic decreasing) in variable i. It is based on Cudd_Decreasing and the
  fact that f is monotonic increasing in i if and only if its complement is
  monotonic decreasing in i.

  Side Effects: None

DdNode *
Cudd_IndicesToCube(
  DdManager *       dd,
  int *             array,
  int               n
)
  Builds a cube of BDD variables from an array of indices. Returns a pointer
  to the result if successful; NULL otherwise.

  Side Effects: None

DdManager *
Cudd_Init(
  unsigned int      numVars,         initial number of BDD variables (i.e.,
                                     subtables)
  unsigned int      numVarsZ,        initial number of ZDD variables (i.e.,
                                     subtables)
  unsigned int      numSlots,        initial size of the unique tables
  unsigned int      cacheSize,       initial size of the cache
  unsigned long     maxMemory        target maximum memory occupation
)
  Creates a new DD manager, initializes the table, the basic constants and the
  projection functions. If maxMemory is 0, Cudd_Init decides suitable values
  for the maximum size of the cache and for the limit for fast unique table
  growth based on the available memory. Returns a pointer to the manager if
  successful; NULL otherwise.

  Side Effects: None


Cudd_IsComplement(
                    node
)
  Returns 1 if a pointer is complemented.

  Side Effects: none


Cudd_IsConstant(
                    node
)
  Returns 1 if the node is a constant node (rather than an internal node). All
  constant nodes have the same index (CUDD_MAXINDEX). The pointer passed to
  Cudd_IsConstant may be either regular or complemented.

  Side Effects: none

int
Cudd_IsGenEmpty(
  DdGen *           gen
)
  Queries the status of a generator. Returns 1 if the generator is empty or
  NULL; 0 otherswise.

  Side Effects: None

int
Cudd_IsNonConstant(
  DdNode *          f
)
  Returns 1 if a DD node is not constant. This function is useful to test the
  results of Cudd_bddIteConstant, Cudd_addIteConstant, Cudd_addEvalConst.
  These results may be a special value signifying non-constant. In the other
  cases the macro Cudd_IsConstant can be used.

  Side Effects: None

void
Cudd_IterDerefBdd(
  DdManager *       table,
  DdNode *          n
)
  Decreases the reference count of node n. If n dies, recursively decreases
  the reference counts of its children. It is used to dispose of a BDD that is
  no longer needed. It is more efficient than Cudd_RecursiveDeref, but it
  cannot be used on ADDs. The greater efficiency comes from being able to
  assume that no constant node will ever die as a result of a call to this
  procedure.

  Side Effects: None

DdNode *
Cudd_LargestCube(
  DdManager *       manager,
  DdNode *          f,
  int *             length
)
  Finds a largest cube in a DD. f is the DD we want to get the largest cube
  for. The problem is translated into the one of finding a shortest path in f,
  when both THEN and ELSE arcs are assumed to have unit length. This yields a
  largest cube in the disjoint cover corresponding to the DD. Therefore, it is
  not necessarily the largest implicant of f. Returns the largest cube as a
  BDD.

  Side Effects: The number of literals of the cube is returned in length.

DdNode *
Cudd_MakeBddFromZddCover(
  DdManager *       dd,
  DdNode *          node
)
  Converts a ZDD cover to a BDD graph. If successful, it returns a BDD node,
  otherwise it returns NULL.


MtrNode *
Cudd_MakeTreeNode(
  DdManager *       dd,              manager
  unsigned int      low,             index of the first group variable
  unsigned int      size,            number of variables in the group
  unsigned int      type             MTR_DEFAULT or MTR_FIXED
)
  Creates a new variable group. The group starts at variable and contains size
  variables. The parameter low is the index of the first variable. If the
  variable already exists, its current position in the order is known to the
  manager. If the variable does not exist yet, the position is assumed to be
  the same as the index. The group tree is created if it does not exist yet.
  Returns a pointer to the group if successful; NULL otherwise.

  Side Effects: The variable tree is changed.

MtrNode *
Cudd_MakeZddTreeNode(
  DdManager *       dd,              manager
  unsigned int      low,             index of the first group variable
  unsigned int      size,            number of variables in the group
  unsigned int      type             MTR_DEFAULT or MTR_FIXED
)
  Creates a new ZDD variable group. The group starts at variable and contains
  size variables. The parameter low is the index of the first variable. If the
  variable already exists, its current position in the order is known to the
  manager. If the variable does not exist yet, the position is assumed to be
  the same as the index. The group tree is created if it does not exist yet.
  Returns a pointer to the group if successful; NULL otherwise.

  Side Effects: The ZDD variable tree is changed.

int
Cudd_MinHammingDist(
  DdManager *       dd,              DD manager
  DdNode *          f,               function to examine
  int *             minterm,         reference minterm
  int               upperBound       distance above which an approximate
                                     answer is OK
)
  Returns the minimum Hamming distance between the minterms of a function f
  and a reference minterm. The function is given as a BDD; the minterm is
  given as an array of integers, one for each variable in the manager. Returns
  the minimum distance if it is less than the upper bound; the upper bound if
  the minimum distance is at least as large; CUDD_OUT_OF_MEM in case of
  failure.

  Side Effects: None

DdApaNumber
Cudd_NewApaNumber(
  int               digits
)
  Allocates memory for an arbitrary precision integer. Returns a pointer to
  the allocated memory if successful; NULL otherwise.

  Side Effects: None

int
Cudd_NextCube(
  DdGen *           gen,
  int **            cube,
  CUDD_VALUE_TYPE * value
)
  Generates the next cube of a decision diagram onset, using generator gen.
  Returns 0 if the enumeration is completed; 1 otherwise.

  Side Effects: The cube and its value are returned as side effects. The
  generator is modified.

int
Cudd_NextNode(
  DdGen *           gen,
  DdNode **         node
)
  Finds the node of a decision diagram, using generator gen. Returns 0 if the
  enumeration is completed; 1 otherwise.

  Side Effects: The next node is returned as a side effect.

unsigned int
Cudd_NodeReadIndex(
  DdNode *          node
)
  Returns the index of the node. The node pointer can be either regular or
  complemented.

  Side Effects: None


Cudd_NotCond(
                    node,
                    c
)
  Complements a DD if condition c is true; c should be either 0 or 1, because
  it is used directly (for efficiency). If in doubt on the values c may take,
  use "(c) ? Cudd_Not(node) : node".

  Side Effects: none


Cudd_Not(
                    node
)
  Complements a DD by flipping the complement attribute of the pointer (the
  least significant bit).

  Side Effects: none

void
Cudd_OutOfMem(
  long              size             size of the allocation that failed
)
  Warns that a memory allocation failed. This function can be used as
  replacement of MMout_of_memory to prevent the safe_mem functions of the util
  package from exiting when malloc returns NULL. One possible use is in case
  of discretionary allocations; for instance, the allocation of memory to
  enlarge the computed table.

  Side Effects: None

DdNode *
Cudd_OverApprox(
  DdManager *       dd,              manager
  DdNode *          f,               function to be superset
  int               numVars,         number of variables in the support of f
  int               threshold,       when to stop approximation
  int               safe,            enforce safe approximation
  double            quality          minimum improvement for accepted changes
)
  Extracts a dense superset from a BDD. The procedure is identical to the
  underapproximation procedure except for the fact that it works on the
  complement of the given function. Extracting the subset of the complement
  function is equivalent to extracting the superset of the function. Returns a
  pointer to the BDD of the superset if successful. NULL if intermediate
  result causes the procedure to run out of memory. The parameter numVars is
  the maximum number of variables to be used in minterm calculation. The
  optimal number should be as close as possible to the size of the support of
  f. However, it is safe to pass the value returned by Cudd_ReadSize for
  numVars when the number of variables is under 1023. If numVars is larger
  than 1023, it will overflow. If a 0 parameter is passed then the procedure
  will compute a value which will avoid overflow but will cause underflow with
  2046 variables or more.

  Side Effects: None

unsigned int
Cudd_Prime(
  unsigned int      p
)
  Returns the next prime >= p.

  Side Effects: None

int
Cudd_PrintDebug(
  DdManager *       dd,
  DdNode *          f,
  int               n,
  int               pr
)
  Prints to the standard output a DD and its statistics. The statistics
  include the number of nodes, the number of leaves, and the number of
  minterms. (The number of minterms is the number of assignments to the
  variables that cause the function to be different from the logical zero (for
  BDDs) and from the background value (for ADDs.) The statistics are printed
  if pr > 0. Specifically:   pr = 0 : prints nothing  pr = 1 :
  prints counts of nodes and minterms  pr = 2 : prints counts + disjoint
  sum of product  pr = 3 : prints counts + list of nodes  pr > 3 :
  prints counts + disjoint sum of product + list of nodes  Returns 1 if
  successful; 0 otherwise.

  Side Effects: None

int
Cudd_PrintInfo(
  DdManager *       dd,
  FILE *            fp
)
  Prints out statistics and settings for a CUDD manager. Returns 1 if
  successful; 0 otherwise.

  Side Effects: None

int
Cudd_PrintLinear(
  DdManager *       table
)
  Prints the linear transform matrix. Returns 1 in case of success; 0
  otherwise.

  Side Effects: none

int
Cudd_PrintMinterm(
  DdManager *       manager,
  DdNode *          node
)
  Prints a disjoint sum of product cover for the function rooted at node. Each
  product corresponds to a path from node a leaf node different from the
  logical zero, and different from the background value. Uses the standard
  output. Returns 1 if successful; 0 otherwise.

  Side Effects: None

void
Cudd_PrintVersion(
  FILE *            fp
)
  Prints the package version number.

  Side Effects: None

void
Cudd_Quit(
  DdManager *       unique
)
  Deletes resources associated with a DD manager and resets the global
  statistical counters. (Otherwise, another manaqger subsequently created
  would inherit the stats of this one.)

  Side Effects: None

long
Cudd_Random(

)
  Portable number generator based on ran2 from "Numerical Recipes in C." It is
  a long period (> 2 * 10^18) random number generator of L'Ecuyer with Bays-
  Durham shuffle. Returns a long integer uniformly distributed between 0 and
  2147483561 (inclusive of the endpoint values). The ranom generator can be
  explicitly initialized by calling Cudd_Srandom. If no explicit
  initialization is performed, then the seed 1 is assumed.

  Side Effects: None

int
Cudd_ReadArcviolation(
  DdManager *       dd
)
  Returns the current value of the arcviolation parameter. This parameter is
  used in group sifting to decide how many arcs into y not coming
  from x are tolerable when checking for aggregation due to
  extended symmetry. The value should be between 0 and 100. A small value
  causes fewer variables to be aggregated. The default value is 0.

  Side Effects: None

DdNode *
Cudd_ReadBackground(
  DdManager *       dd
)
  Reads the background constant of the manager.

  Side Effects: None

double
Cudd_ReadCacheHits(
  DdManager *       dd
)
  Returns the number of cache hits.

  Side Effects: None

double
Cudd_ReadCacheLookUps(
  DdManager *       dd
)
  Returns the number of cache look-ups.

  Side Effects: None

unsigned int
Cudd_ReadCacheSlots(
  DdManager *       dd
)
  Reads the number of slots in the cache.

  Side Effects: None

double
Cudd_ReadCacheUsedSlots(
  DdManager *       dd
)
  Reads the fraction of used slots in the cache. The unused slots are those in
  which no valid data is stored. Garbage collection, variable reordering, and
  cache resizing may cause used slots to become unused.

  Side Effects: None

unsigned int
Cudd_ReadDead(
  DdManager *       dd
)
  Returns the number of dead nodes in the unique table.

  Side Effects: None

CUDD_VALUE_TYPE
Cudd_ReadEpsilon(
  DdManager *       dd
)
  Reads the epsilon parameter of the manager. The epsilon parameter control
  the comparison between floating point numbers.

  Side Effects: None

Cudd_ErrorType
Cudd_ReadErrorCode(
  DdManager *       dd
)
  Returns the code of the last error. The error codes are defined in cudd.h.

  Side Effects: None

long
Cudd_ReadGarbageCollectionTime(
  DdManager *       dd
)
  Returns the number of milliseconds spent doing garbage collection since the
  manager was initialized.

  Side Effects: None

int
Cudd_ReadGarbageCollections(
  DdManager *       dd
)
  Returns the number of times garbage collection has occurred in the manager.
  The number includes both the calls from reordering procedures and those
  caused by requests to create new nodes.

  Side Effects: None

Cudd_AggregationType
Cudd_ReadGroupcheck(
  DdManager *       dd
)
  Reads the groupcheck parameter of the manager. The groupcheck parameter
  determines the aggregation criterion in group sifting.

  Side Effects: None


Cudd_ReadIndex(
                    dd,
                    index
)
  Returns the current position in the order of variable index. This macro is
  obsolete and is kept for compatibility. New applications should use
  Cudd_ReadPerm instead.

  Side Effects: none

int
Cudd_ReadInvPermZdd(
  DdManager *       dd,
  int               i
)
  Returns the index of the ZDD variable currently in the i-th position of the
  order. If the index is CUDD_MAXINDEX, returns CUDD_MAXINDEX; otherwise, if
  the index is out of bounds returns -1.

  Side Effects: None

int
Cudd_ReadInvPerm(
  DdManager *       dd,
  int               i
)
  Returns the index of the variable currently in the i-th position of the
  order. If the index is CUDD_MAXINDEX, returns CUDD_MAXINDEX; otherwise, if
  the index is out of bounds returns -1.

  Side Effects: None

unsigned int
Cudd_ReadKeys(
  DdManager *       dd
)
  Returns the total number of nodes currently in the unique table, including
  the dead nodes.

  Side Effects: None

int
Cudd_ReadLinear(
  DdManager *       table,           CUDD manager
  int               x,               row index
  int               y                column index
)
  Reads an entry of the linear transform matrix.

  Side Effects: none

DdNode *
Cudd_ReadLogicZero(
  DdManager *       dd
)
  Returns the zero constant of the manager. The logic zero constant is the
  complement of the one constant, and is distinct from the arithmetic zero.

  Side Effects: None

unsigned int
Cudd_ReadLooseUpTo(
  DdManager *       dd
)
  Reads the looseUpTo parameter of the manager.

  Side Effects: None

unsigned int
Cudd_ReadMaxCacheHard(
  DdManager *       dd
)
  Reads the maxCacheHard parameter of the manager.

  Side Effects: None

unsigned int
Cudd_ReadMaxCache(
  DdManager *       dd
)
  Returns the soft limit for the cache size. The soft limit

  Side Effects: None

double
Cudd_ReadMaxGrowth(
  DdManager *       dd
)
  Reads the maxGrowth parameter of the manager. This parameter determines how
  much the number of nodes can grow during sifting of a variable. Overall,
  sifting never increases the size of the decision diagrams. This parameter
  only refers to intermediate results. A lower value will speed up sifting,
  possibly at the expense of quality.

  Side Effects: None

unsigned int
Cudd_ReadMaxLive(
  DdManager *       dd
)
  Reads the maximum allowed number of live nodes. When this number is
  exceeded, the package returns NULL.

  Side Effects: none

long
Cudd_ReadMaxMemory(
  DdManager *       dd
)
  Reads the maximum allowed memory. When this number is exceeded, the package
  returns NULL.

  Side Effects: none

long
Cudd_ReadMemoryInUse(
  DdManager *       dd
)
  Returns the memory in use by the manager measured in bytes.

  Side Effects: None

unsigned int
Cudd_ReadMinDead(
  DdManager *       dd
)
  Reads the minDead parameter of the manager. The minDead parameter is used by
  the package to decide whether to collect garbage or resize a subtable of the
  unique table when the subtable becomes too full. The application can
  indirectly control the value of minDead by setting the looseUpTo parameter.

  Side Effects: None

unsigned int
Cudd_ReadMinHit(
  DdManager *       dd
)
  Reads the hit ratio that causes resizinig of the computed table.

  Side Effects: None

DdNode *
Cudd_ReadMinusInfinity(
  DdManager *       dd
)
  Reads the minus-infinity constant from the manager.

  Side Effects: None

unsigned int
Cudd_ReadNextReordering(
  DdManager *       dd
)
  Returns the threshold for the next dynamic reordering. The threshold is in
  terms of number of nodes and is in effect only if reordering is enabled. The
  count does not include the dead nodes, unless the countDead parameter of the
  manager has been changed from its default setting.

  Side Effects: None

long
Cudd_ReadNodeCount(
  DdManager *       dd
)
  Reports the number of live nodes in BDDs and ADDs. This number does not
  include the isolated projection functions and the unused constants. These
  nodes that are not counted are not part of the DDs manipulated by the
  application.

  Side Effects: None

double
Cudd_ReadNodesDropped(
  DdManager *       dd
)
  Returns the number of nodes killed by dereferencing if the keeping of this
  statistic is enabled; -1 otherwise. This statistic is enabled only if the
  package is compiled with DD_STATS defined.

  Side Effects: None

double
Cudd_ReadNodesFreed(
  DdManager *       dd
)
  Returns the number of nodes returned to the free list if the keeping of this
  statistic is enabled; -1 otherwise. This statistic is enabled only if the
  package is compiled with DD_STATS defined.

  Side Effects: None

int
Cudd_ReadNumberXovers(
  DdManager *       dd
)
  Reads the current number of crossovers used by the genetic algorithm for
  variable reordering. A larger number of crossovers will cause the genetic
  algorithm to take more time, but will generally produce better results. The
  default value is 0, in which case the package uses three times the number of
  variables as number of crossovers, with a maximum of 60.

  Side Effects: None

DdNode *
Cudd_ReadOne(
  DdManager *       dd
)
  Returns the one constant of the manager. The one constant is common to ADDs
  and BDDs.

  Side Effects: None

int
Cudd_ReadPeakLiveNodeCount(
  DdManager *       dd
)
  Reports the peak number of live nodes. This count is kept only if CUDD is
  compiled with DD_STATS defined. If DD_STATS is not defined, this function
  returns -1.

  Side Effects: None

long
Cudd_ReadPeakNodeCount(
  DdManager *       dd
)
  Reports the peak number of nodes. This number includes node on the free
  list. At the peak, the number of nodes on the free list is guaranteed to be
  less than DD_MEM_CHUNK.

  Side Effects: None

int
Cudd_ReadPermZdd(
  DdManager *       dd,
  int               i
)
  Returns the current position of the i-th ZDD variable in the order. If the
  index is CUDD_MAXINDEX, returns CUDD_MAXINDEX; otherwise, if the index is
  out of bounds returns -1.

  Side Effects: None

int
Cudd_ReadPerm(
  DdManager *       dd,
  int               i
)
  Returns the current position of the i-th variable in the order. If the index
  is CUDD_MAXINDEX, returns CUDD_MAXINDEX; otherwise, if the index is out of
  bounds returns -1.

  Side Effects: None

DdNode *
Cudd_ReadPlusInfinity(
  DdManager *       dd
)
  Reads the plus-infinity constant from the manager.

  Side Effects: None

int
Cudd_ReadPopulationSize(
  DdManager *       dd
)
  Reads the current size of the population used by the genetic algorithm for
  variable reordering. A larger population size will cause the genetic
  algorithm to take more time, but will generally produce better results. The
  default value is 0, in which case the package uses three times the number of
  variables as population size, with a maximum of 120.

  Side Effects: None

int
Cudd_ReadRecomb(
  DdManager *       dd
)
  Returns the current value of the recombination parameter used in group
  sifting. A larger (positive) value makes the aggregation of variables due to
  the second difference criterion more likely. A smaller (negative) value
  makes aggregation less likely.

  Side Effects: None

double
Cudd_ReadRecursiveCalls(
  DdManager *       dd
)
  Returns the number of recursive calls if the package is compiled with
  DD_COUNT defined.

  Side Effects: None

long
Cudd_ReadReorderingTime(
  DdManager *       dd
)
  Returns the number of milliseconds spent reordering variables since the
  manager was initialized. The time spent in collecting garbage before
  reordering is included.

  Side Effects: None

int
Cudd_ReadReorderings(
  DdManager *       dd
)
  Returns the number of times reordering has occurred in the manager. The
  number includes both the calls to Cudd_ReduceHeap from the application
  program and those automatically performed by the package. However, calls
  that do not even initiate reordering are not counted. A call may not
  initiate reordering if there are fewer than minsize live nodes in the
  manager, or if CUDD_REORDER_NONE is specified as reordering method. The
  calls to Cudd_ShuffleHeap are not counted.

  Side Effects: None

int
Cudd_ReadSiftMaxSwap(
  DdManager *       dd
)
  Reads the siftMaxSwap parameter of the manager. This parameter gives the
  maximum number of swaps that will be attempted for each invocation of
  sifting. The real number of swaps may exceed the set limit because the
  package will always complete the sifting of the variable that causes the
  limit to be reached.

  Side Effects: None

int
Cudd_ReadSiftMaxVar(
  DdManager *       dd
)
  Reads the siftMaxVar parameter of the manager. This parameter gives the
  maximum number of variables that will be sifted for each invocation of
  sifting.

  Side Effects: None

int
Cudd_ReadSize(
  DdManager *       dd
)
  Returns the number of BDD variables in existance.

  Side Effects: None

unsigned int
Cudd_ReadSlots(
  DdManager *       dd
)
  Returns the total number of slots of the unique table. This number ismainly
  for diagnostic purposes.

  Side Effects: None

FILE *
Cudd_ReadStderr(
  DdManager *       dd
)
  Reads the stderr of a manager. This is the file pointer to which messages
  normally going to stderr are written. It is initialized to stderr.
  Cudd_SetStderr allows the application to redirect it.

  Side Effects: None

FILE *
Cudd_ReadStdout(
  DdManager *       dd
)
  Reads the stdout of a manager. This is the file pointer to which messages
  normally going to stdout are written. It is initialized to stdout.
  Cudd_SetStdout allows the application to redirect it.

  Side Effects: None

double
Cudd_ReadSwapSteps(
  DdManager *       dd
)
  Reads the number of elementary reordering steps.

  Side Effects: none

int
Cudd_ReadSymmviolation(
  DdManager *       dd
)
  Returns the current value of the symmviolation parameter. This parameter is
  used in group sifting to decide how many violations to the symmetry
  conditions f10 = f01 or f11 = f00 are tolerable
  when checking for aggregation due to extended symmetry. The value should be
  between 0 and 100. A small value causes fewer variables to be aggregated.
  The default value is 0.

  Side Effects: None

MtrNode *
Cudd_ReadTree(
  DdManager *       dd
)
  Returns the variable group tree of the manager.

  Side Effects: None

double
Cudd_ReadUniqueLinks(
  DdManager *       dd
)
  Returns the number of links followed during look-ups in the unique table if
  the keeping of this statistic is enabled; -1 otherwise. If an item is found
  in the first position of its collision list, the number of links followed is
  taken to be 0. If it is in second position, the number of links is 1, and so
  on. This statistic is enabled only if the package is compiled with
  DD_UNIQUE_PROFILE defined.

  Side Effects: None

double
Cudd_ReadUniqueLookUps(
  DdManager *       dd
)
  Returns the number of look-ups in the unique table if the keeping of this
  statistic is enabled; -1 otherwise. This statistic is enabled only if the
  package is compiled with DD_UNIQUE_PROFILE defined.

  Side Effects: None

double
Cudd_ReadUsedSlots(
  DdManager *       dd
)
  Reads the fraction of used slots in the unique table. The unused slots are
  those in which no valid data is stored. Garbage collection, variable
  reordering, and subtable resizing may cause used slots to become unused.

  Side Effects: None

DdNode *
Cudd_ReadVars(
  DdManager *       dd,
  int               i
)
  Returns the i-th element of the vars array if it falls within the array
  bounds; NULL otherwise. If i is the index of an existing variable, this
  function produces the same result as Cudd_bddIthVar. However, if the i-th
  var does not exist yet, Cudd_bddIthVar will create it, whereas Cudd_ReadVars
  will not.

  Side Effects: None

DdNode *
Cudd_ReadZddOne(
  DdManager *       dd,
  int               i
)
  Returns the ZDD for the constant 1 function. The representation of the
  constant 1 function as a ZDD depends on how many variables it (nominally)
  depends on. The index of the topmost variable in the support is given as
  argument i.

  Side Effects: None

int
Cudd_ReadZddSize(
  DdManager *       dd
)
  Returns the number of ZDD variables in existance.

  Side Effects: None

MtrNode *
Cudd_ReadZddTree(
  DdManager *       dd
)
  Returns the variable group tree of the manager.

  Side Effects: None

DdNode *
Cudd_ReadZero(
  DdManager *       dd
)
  Returns the zero constant of the manager. The zero constant is the
  arithmetic zero, rather than the logic zero. The latter is the complement of
  the one constant.

  Side Effects: None

void
Cudd_RecursiveDerefZdd(
  DdManager *       table,
  DdNode *          n
)
  Decreases the reference count of ZDD node n. If n dies, recursively
  decreases the reference counts of its children. It is used to dispose of a
  ZDD that is no longer needed.

  Side Effects: None

void
Cudd_RecursiveDeref(
  DdManager *       table,
  DdNode *          n
)
  Decreases the reference count of node n. If n dies, recursively decreases
  the reference counts of its children. It is used to dispose of a DD that is
  no longer needed.

  Side Effects: None

int
Cudd_ReduceHeap(
  DdManager *       table,           DD manager
  Cudd_ReorderingTy heuristic,       method used for reordering
  int               minsize          bound below which no reordering occurs
)
  Main dynamic reordering routine. Calls one of the possible reordering
  procedures:  Swapping Sifting Symmetric Sifting Group
  Sifting Window Permutation Simulated Annealing Genetic Algorithm
  Dynamic Programming (exact)  For sifting, symmetric sifting, group
  sifting, and window permutation it is possible to request reordering to
  convergence. The core of all methods is the reordering procedure
  cuddSwapInPlace() which swaps two adjacent variables and is based on
  Rudell's paper. Returns 1 in case of success; 0 otherwise. In the case of
  symmetric sifting (with and without convergence) returns 1 plus the number
  of symmetric variables, in case of success.

  Side Effects: Changes the variable order for all diagrams and clears the
  cache.

void
Cudd_Ref(
  DdNode *          n
)
  Increases the reference count of a node, if it is not saturated.

  Side Effects: None


Cudd_Regular(
                    node
)
  Returns the regular version of a pointer.

  Side Effects: none

DdNode *
Cudd_RemapOverApprox(
  DdManager *       dd,              manager
  DdNode *          f,               function to be superset
  int               numVars,         number of variables in the support of f
  int               threshold,       when to stop approximation
  double            quality          minimum improvement for accepted changes
)
  Extracts a dense superset from a BDD. The procedure is identical to the
  underapproximation procedure except for the fact that it works on the
  complement of the given function. Extracting the subset of the complement
  function is equivalent to extracting the superset of the function. Returns a
  pointer to the BDD of the superset if successful. NULL if intermediate
  result causes the procedure to run out of memory. The parameter numVars is
  the maximum number of variables to be used in minterm calculation. The
  optimal number should be as close as possible to the size of the support of
  f. However, it is safe to pass the value returned by Cudd_ReadSize for
  numVars when the number of variables is under 1023. If numVars is larger
  than 1023, it will overflow. If a 0 parameter is passed then the procedure
  will compute a value which will avoid overflow but will cause underflow with
  2046 variables or more.

  Side Effects: None

DdNode *
Cudd_RemapUnderApprox(
  DdManager *       dd,              manager
  DdNode *          f,               function to be subset
  int               numVars,         number of variables in the support of f
  int               threshold,       when to stop approximation
  double            quality          minimum improvement for accepted changes
)
  Extracts a dense subset from a BDD. This procedure uses a remapping
  technique and density as the cost function. Returns a pointer to the BDD of
  the subset if successful. NULL if the procedure runs out of memory. The
  parameter numVars is the maximum number of variables to be used in minterm
  calculation. The optimal number should be as close as possible to the size
  of the support of f. However, it is safe to pass the value returned by
  Cudd_ReadSize for numVars when the number of variables is under 1023. If
  numVars is larger than 1023, it will cause overflow. If a 0 parameter is
  passed then the procedure will compute a value which will avoid overflow but
  will cause underflow with 2046 variables or more.

  Side Effects: None

int
Cudd_ReorderingReporting(
  DdManager *       dd
)
  Returns 1 if reporting of reordering stats is enabled; 0 otherwise.

  Side Effects: none

int
Cudd_ReorderingStatusZdd(
  DdManager *       unique,
  Cudd_ReorderingTy method
)
  Reports the status of automatic dynamic reordering of ZDDs. Parameter method
  is set to the ZDD reordering method currently selected. Returns 1 if
  automatic reordering is enabled; 0 otherwise.

  Side Effects: Parameter method is set to the ZDD reordering method currently
  selected.

int
Cudd_ReorderingStatus(
  DdManager *       unique,
  Cudd_ReorderingTy method
)
  Reports the status of automatic dynamic reordering of BDDs and ADDs.
  Parameter method is set to the reordering method currently selected. Returns
  1 if automatic reordering is enabled; 0 otherwise.

  Side Effects: Parameter method is set to the reordering method currently
  selected.

void
Cudd_SetArcviolation(
  DdManager *       dd,
  int               arcviolation
)
  Sets the value of the arcviolation parameter. This parameter is used in
  group sifting to decide how many arcs into y not coming from
  x are tolerable when checking for aggregation due to extended
  symmetry. The value should be between 0 and 100. A small value causes fewer
  variables to be aggregated. The default value is 0.

  Side Effects: None

void
Cudd_SetBackground(
  DdManager *       dd,
  DdNode *          bck
)
  Sets the background constant of the manager. It assumes that the DdNode
  pointer bck is already referenced.

  Side Effects: None

void
Cudd_SetEpsilon(
  DdManager *       dd,
  CUDD_VALUE_TYPE   ep
)
  Sets the epsilon parameter of the manager to ep. The epsilon parameter
  control the comparison between floating point numbers.

  Side Effects: None

void
Cudd_SetGroupcheck(
  DdManager *       dd,
  Cudd_AggregationT gc
)
  Sets the parameter groupcheck of the manager to gc. The groupcheck parameter
  determines the aggregation criterion in group sifting.

  Side Effects: None

void
Cudd_SetLooseUpTo(
  DdManager *       dd,
  unsigned int      lut
)
  Sets the looseUpTo parameter of the manager. This parameter of the manager
  controls the threshold beyond which no fast growth of the unique table is
  allowed. The threshold is given as a number of slots. If the value passed to
  this function is 0, the function determines a suitable value based on the
  available memory.

  Side Effects: None

void
Cudd_SetMaxCacheHard(
  DdManager *       dd,
  unsigned int      mc
)
  Sets the maxCacheHard parameter of the manager. The cache cannot grow larger
  than maxCacheHard entries. This parameter allows an application to control
  the trade-off of memory versus speed. If the value passed to this function
  is 0, the function determines a suitable maximum cache size based on the
  available memory.

  Side Effects: None

void
Cudd_SetMaxGrowth(
  DdManager *       dd,
  double            mg
)
  Sets the maxGrowth parameter of the manager. This parameter determines how
  much the number of nodes can grow during sifting of a variable. Overall,
  sifting never increases the size of the decision diagrams. This parameter
  only refers to intermediate results. A lower value will speed up sifting,
  possibly at the expense of quality.

  Side Effects: None

void
Cudd_SetMaxLive(
  DdManager *       dd,
  unsigned int      maxLive
)
  Sets the maximum allowed number of live nodes. When this number is exceeded,
  the package returns NULL.

  Side Effects: none

void
Cudd_SetMaxMemory(
  DdManager *       dd,
  long              maxMemory
)
  Sets the maximum allowed memory. When this number is exceeded, the package
  returns NULL.

  Side Effects: none

void
Cudd_SetMinHit(
  DdManager *       dd,
  unsigned int      hr
)
  Sets the minHit parameter of the manager. This parameter controls the
  resizing of the computed table. If the hit ratio is larger than the
  specified value, and the cache is not already too large, then its size is
  doubled.

  Side Effects: None

void
Cudd_SetNextReordering(
  DdManager *       dd,
  unsigned int      next
)
  Sets the threshold for the next dynamic reordering. The threshold is in
  terms of number of nodes and is in effect only if reordering is enabled. The
  count does not include the dead nodes, unless the countDead parameter of the
  manager has been changed from its default setting.

  Side Effects: None

void
Cudd_SetNumberXovers(
  DdManager *       dd,
  int               numberXovers
)
  Sets the number of crossovers used by the genetic algorithm for variable
  reordering. A larger number of crossovers will cause the genetic algorithm
  to take more time, but will generally produce better results. The default
  value is 0, in which case the package uses three times the number of
  variables as number of crossovers, with a maximum of 60.

  Side Effects: None

void
Cudd_SetPopulationSize(
  DdManager *       dd,
  int               populationSize
)
  Sets the size of the population used by the genetic algorithm for variable
  reordering. A larger population size will cause the genetic algorithm to
  take more time, but will generally produce better results. The default value
  is 0, in which case the package uses three times the number of variables as
  population size, with a maximum of 120.

  Side Effects: Changes the manager.

void
Cudd_SetRecomb(
  DdManager *       dd,
  int               recomb
)
  Sets the value of the recombination parameter used in group sifting. A
  larger (positive) value makes the aggregation of variables due to the second
  difference criterion more likely. A smaller (negative) value makes
  aggregation less likely. The default value is 0.

  Side Effects: Changes the manager.

void
Cudd_SetSiftMaxSwap(
  DdManager *       dd,
  int               sms
)
  Sets the siftMaxSwap parameter of the manager. This parameter gives the
  maximum number of swaps that will be attempted for each invocation of
  sifting. The real number of swaps may exceed the set limit because the
  package will always complete the sifting of the variable that causes the
  limit to be reached.

  Side Effects: None

void
Cudd_SetSiftMaxVar(
  DdManager *       dd,
  int               smv
)
  Sets the siftMaxVar parameter of the manager. This parameter gives the
  maximum number of variables that will be sifted for each invocation of
  sifting.

  Side Effects: None

void
Cudd_SetStderr(
  DdManager *       dd,
  FILE *            fp
)
  Sets the stderr of a manager.

  Side Effects: None

void
Cudd_SetStdout(
  DdManager *       dd,
  FILE *            fp
)
  Sets the stdout of a manager.

  Side Effects: None

void
Cudd_SetSymmviolation(
  DdManager *       dd,
  int               symmviolation
)
  Sets the value of the symmviolation parameter. This parameter is used in
  group sifting to decide how many violations to the symmetry conditions
  f10 = f01 or f11 = f00 are tolerable when checking
  for aggregation due to extended symmetry. The value should be between 0 and
  100. A small value causes fewer variables to be aggregated. The default
  value is 0.

  Side Effects: Changes the manager.

void
Cudd_SetTree(
  DdManager *       dd,
  MtrNode *         tree
)
  Sets the variable group tree of the manager.

  Side Effects: None

int
Cudd_SetVarMap(
  DdManager *       manager,         DD manager
  DdNode **         x,               first array of variables
  DdNode **         y,               second array of variables
  int               n                length of both arrays
)
  Registers with the manager a variable mapping described by two sets of
  variables. This variable mapping is then used by functions like
  Cudd_bddFastSwap. This function is convenient for those applications that
  perform the same mapping several times. However, if several different
  permutations are used, it may be more efficient not to rely on the
  registered mapping, because changing mapping causes the cache to be cleared.
  (The initial setting, however, does not clear the cache.) The two sets of
  variables (x and y) must have the same size (x and y). The size is given by
  n. The two sets of variables are normally disjoint, but this restriction is
  not imposeded by the function. When new variables are created, the map is
  automatically extended (each new variable maps to itself). The typical use,
  however, is to wait until all variables are created, and then create the
  map. Returns 1 if the mapping is successfully registered with the manager; 0
  otherwise.

  Side Effects: Modifies the manager. May clear the cache.

void
Cudd_SetZddTree(
  DdManager *       dd,
  MtrNode *         tree
)
  Sets the ZDD variable group tree of the manager.

  Side Effects: None

int
Cudd_SharingSize(
  DdNode **         nodeArray,
  int               n
)
  Counts the number of nodes in an array of DDs. Shared nodes are counted only
  once. Returns the total number of nodes.

  Side Effects: None

int
Cudd_ShortestLength(
  DdManager *       manager,
  DdNode *          f,
  int *             weight
)
  Find the length of the shortest path(s) in a DD. f is the DD we want to get
  the shortest path for; weight[i] is the weight of the THEN edge coming from
  the node whose index is i. All ELSE edges have 0 weight. Returns the length
  of the shortest path(s) if successful; CUDD_OUT_OF_MEM otherwise.

  Side Effects: None

DdNode *
Cudd_ShortestPath(
  DdManager *       manager,
  DdNode *          f,
  int *             weight,
  int *             support,
  int *             length
)
  Finds a shortest path in a DD. f is the DD we want to get the shortest path
  for; weight[i] is the weight of the THEN arc coming from the node whose
  index is i. If weight is NULL, then unit weights are assumed for all THEN
  arcs. All ELSE arcs have 0 weight. If non-NULL, both weight and support
  should point to arrays with at least as many entries as there are variables
  in the manager. Returns the shortest path as the BDD of a cube.

  Side Effects: support contains on return the true support of f. If support
  is NULL on entry, then Cudd_ShortestPath does not compute the true support
  info. length contains the length of the path.

int
Cudd_ShuffleHeap(
  DdManager *       table,           DD manager
  int *             permutation      required variable permutation
)
  Reorders variables according to given permutation. The i-th entry of the
  permutation array contains the index of the variable that should be brought
  to the i-th level. The size of the array should be equal or greater to the
  number of variables currently in use. Returns 1 in case of success; 0
  otherwise.

  Side Effects: Changes the variable order for all diagrams and clears the
  cache.

DdNode *
Cudd_SolveEqn(
  DdManager *       bdd,
  DdNode *          F,               the left-hand side of the equation
  DdNode *          Y,               the cube of the y variables
  DdNode **         G,               the array of solutions (return parameter)
  int **            yIndex,          index of y variables
  int               n                numbers of unknowns
)
  Implements the solution for F(x,y) = 0. The return value is the consistency
  condition. The y variables are the unknowns and the remaining variables are
  the parameters. Returns the consistency condition if successful; NULL
  otherwise. Cudd_SolveEqn allocates an array and fills it with the indices of
  the unknowns. This array is used by Cudd_VerifySol.

  Side Effects: The solution is returned in G; the indices of the y variables
  are returned in yIndex.

DdNode *
Cudd_SplitSet(
  DdManager *       manager,
  DdNode *          S,
  DdNode **         xVars,
  int               n,
  double            m
)
  Returns m minterms from a BDD whose support has n
  variables at most. The procedure tries to create as few extra nodes as
  possible. The function represented by S depends on at most
  n of the variables in xVars. Returns a BDD with
  m minterms of the on-set of S if successful; NULL otherwise.

  Side Effects: None

void
Cudd_Srandom(
  long              seed
)
  Initializer for the portable number generator based on ran2 in "Numerical
  Recipes in C." The input is the seed for the generator. If it is negative,
  its absolute value is taken as seed. If it is 0, then 1 is taken as seed.
  The initialized sets up the two recurrences used to generate a long-period
  stream, and sets up the shuffle table.

  Side Effects: None

int
Cudd_StdPostReordHook(
  DdManager *       dd,
  char *            str,
  void *            data
)
  Sample hook function to call after reordering. Prints on the manager's
  stdout final size and reordering time. Returns 1 if successful; 0 otherwise.

  Side Effects: None

int
Cudd_StdPreReordHook(
  DdManager *       dd,
  char *            str,
  void *            data
)
  Sample hook function to call before reordering. Prints on the manager's
  stdout reordering method and initial size. Returns 1 if successful; 0
  otherwise.

  Side Effects: None

DdNode *
Cudd_SubsetCompress(
  DdManager *       dd,              manager
  DdNode *          f,               BDD whose subset is sought
  int               nvars,           number of variables in the support of f
  int               threshold        maximum number of nodes in the subset
)
  Finds a dense subset of BDD f. Density is the ratio of number
  of minterms to number of nodes. Uses several techniques in series. It is
  more expensive than other subsetting procedures, but often produces better
  results. See Cudd_SubsetShortPaths for a description of the threshold and
  nvars parameters. Returns a pointer to the result if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_SubsetHeavyBranch(
  DdManager *       dd,              manager
  DdNode *          f,               function to be subset
  int               numVars,         number of variables in the support of f
  int               threshold        maximum number of nodes in the subset
)
  Extracts a dense subset from a BDD. This procedure builds a subset by
  throwing away one of the children of each node, starting from the root,
  until the result is small enough. The child that is eliminated from the
  result is the one that contributes the fewer minterms. Returns a pointer to
  the BDD of the subset if successful. NULL if the procedure runs out of
  memory. The parameter numVars is the maximum number of variables to be used
  in minterm calculation and node count calculation. The optimal number should
  be as close as possible to the size of the support of f. However, it is safe
  to pass the value returned by Cudd_ReadSize for numVars when the number of
  variables is under 1023. If numVars is larger than 1023, it will overflow.
  If a 0 parameter is passed then the procedure will compute a value which
  will avoid overflow but will cause underflow with 2046 variables or more.

  Side Effects: None

DdNode *
Cudd_SubsetShortPaths(
  DdManager *       dd,              manager
  DdNode *          f,               function to be subset
  int               numVars,         number of variables in the support of f
  int               threshold,       maximum number of nodes in the subset
  int               hardlimit        flag: 1 if threshold is a hard limit
)
  Extracts a dense subset from a BDD. This procedure tries to preserve the
  shortest paths of the input BDD, because they give many minterms and
  contribute few nodes. This procedure may increase the number of nodes in
  trying to create the subset or reduce the number of nodes due to
  recombination as compared to the original BDD. Hence the threshold may not
  be strictly adhered to. In practice, recombination overshadows the increase
  in the number of nodes and results in small BDDs as compared to the
  threshold. The hardlimit specifies whether threshold needs to be strictly
  adhered to. If it is set to 1, the procedure ensures that result is never
  larger than the specified limit but may be considerably less than the
  threshold. Returns a pointer to the BDD for the subset if successful; NULL
  otherwise. The value for numVars should be as close as possible to the size
  of the support of f for better efficiency. However, it is safe to pass the
  value returned by Cudd_ReadSize for numVars. If 0 is passed, then the value
  returned by Cudd_ReadSize is used.

  Side Effects: None

DdNode *
Cudd_SupersetCompress(
  DdManager *       dd,              manager
  DdNode *          f,               BDD whose superset is sought
  int               nvars,           number of variables in the support of f
  int               threshold        maximum number of nodes in the superset
)
  Finds a dense superset of BDD f. Density is the ratio of number
  of minterms to number of nodes. Uses several techniques in series. It is
  more expensive than other supersetting procedures, but often produces better
  results. See Cudd_SupersetShortPaths for a description of the threshold and
  nvars parameters. Returns a pointer to the result if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_SupersetHeavyBranch(
  DdManager *       dd,              manager
  DdNode *          f,               function to be superset
  int               numVars,         number of variables in the support of f
  int               threshold        maximum number of nodes in the superset
)
  Extracts a dense superset from a BDD. The procedure is identical to the
  subset procedure except for the fact that it receives the complement of the
  given function. Extracting the subset of the complement function is
  equivalent to extracting the superset of the function. This procedure builds
  a superset by throwing away one of the children of each node starting from
  the root of the complement function, until the result is small enough. The
  child that is eliminated from the result is the one that contributes the
  fewer minterms. Returns a pointer to the BDD of the superset if successful.
  NULL if intermediate result causes the procedure to run out of memory. The
  parameter numVars is the maximum number of variables to be used in minterm
  calculation and node count calculation. The optimal number should be as
  close as possible to the size of the support of f. However, it is safe to
  pass the value returned by Cudd_ReadSize for numVars when the number of
  variables is under 1023. If numVars is larger than 1023, it will overflow.
  If a 0 parameter is passed then the procedure will compute a value which
  will avoid overflow but will cause underflow with 2046 variables or more.

  Side Effects: None

DdNode *
Cudd_SupersetShortPaths(
  DdManager *       dd,              manager
  DdNode *          f,               function to be superset
  int               numVars,         number of variables in the support of f
  int               threshold,       maximum number of nodes in the subset
  int               hardlimit        flag: 1 if threshold is a hard limit
)
  Extracts a dense superset from a BDD. The procedure is identical to the
  subset procedure except for the fact that it receives the complement of the
  given function. Extracting the subset of the complement function is
  equivalent to extracting the superset of the function. This procedure tries
  to preserve the shortest paths of the complement BDD, because they give many
  minterms and contribute few nodes. This procedure may increase the number of
  nodes in trying to create the superset or reduce the number of nodes due to
  recombination as compared to the original BDD. Hence the threshold may not
  be strictly adhered to. In practice, recombination overshadows the increase
  in the number of nodes and results in small BDDs as compared to the
  threshold. The hardlimit specifies whether threshold needs to be strictly
  adhered to. If it is set to 1, the procedure ensures that result is never
  larger than the specified limit but may be considerably less than the
  threshold. Returns a pointer to the BDD for the superset if successful; NULL
  otherwise. The value for numVars should be as close as possible to the size
  of the support of f for better efficiency. However, it is safe to pass the
  value returned by Cudd_ReadSize for numVar. If 0 is passed, then the value
  returned by Cudd_ReadSize is used.

  Side Effects: None

int
Cudd_SupportSize(
  DdManager *       dd,              manager
  DdNode *          f                DD whose support size is sought
)
  Counts the variables on which a DD depends. Returns the number of the
  variables if successful; CUDD_OUT_OF_MEM otherwise.

  Side Effects: None

DdNode *
Cudd_Support(
  DdManager *       dd,              manager
  DdNode *          f                DD whose support is sought
)
  Finds the variables on which a DD depends. Returns a BDD consisting of the
  product of the variables if successful; NULL otherwise.

  Side Effects: None

void
Cudd_SymmProfile(
  DdManager *       table,
  int               lower,
  int               upper
)
  Prints statistics on symmetric variables.

  Side Effects: None

void
Cudd_TurnOffCountDead(
  DdManager *       dd
)
  Causes the dead nodes not to be counted towards triggering reordering. This
  causes less frequent reorderings. By default dead nodes are not counted.
  Therefore there is no need to call this function unless Cudd_TurnOnCountDead
  has been previously called.

  Side Effects: Changes the manager.

void
Cudd_TurnOnCountDead(
  DdManager *       dd
)
  Causes the dead nodes to be counted towards triggering reordering. This
  causes more frequent reorderings. By default dead nodes are not counted.

  Side Effects: Changes the manager.


Cudd_T(
                    node
)
  Returns the then child of an internal node. If node is a
  constant node, the result is unpredictable.

  Side Effects: none

DdNode *
Cudd_UnderApprox(
  DdManager *       dd,              manager
  DdNode *          f,               function to be subset
  int               numVars,         number of variables in the support of f
  int               threshold,       when to stop approximation
  int               safe,            enforce safe approximation
  double            quality          minimum improvement for accepted changes
)
  Extracts a dense subset from a BDD. This procedure uses a variant of Tom
  Shiple's underapproximation method. The main difference from the original
  method is that density is used as cost function. Returns a pointer to the
  BDD of the subset if successful. NULL if the procedure runs out of memory.
  The parameter numVars is the maximum number of variables to be used in
  minterm calculation. The optimal number should be as close as possible to
  the size of the support of f. However, it is safe to pass the value returned
  by Cudd_ReadSize for numVars when the number of variables is under 1023. If
  numVars is larger than 1023, it will cause overflow. If a 0 parameter is
  passed then the procedure will compute a value which will avoid overflow but
  will cause underflow with 2046 variables or more.

  Side Effects: None

int
Cudd_VectorSupportSize(
  DdManager *       dd,              manager
  DdNode **         F,               array of DDs whose support is sought
  int               n                size of the array
)
  Counts the variables on which a set of DDs depends. The set must contain
  either BDDs and ADDs, or ZDDs. Returns the number of the variables if
  successful; CUDD_OUT_OF_MEM otherwise.

  Side Effects: None

DdNode *
Cudd_VectorSupport(
  DdManager *       dd,              manager
  DdNode **         F,               array of DDs whose support is sought
  int               n                size of the array
)
  Finds the variables on which a set of DDs depends. The set must contain
  either BDDs and ADDs, or ZDDs. Returns a BDD consisting of the product of
  the variables if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_VerifySol(
  DdManager *       bdd,
  DdNode *          F,               the left-hand side of the equation
  DdNode **         G,               the array of solutions
  int *             yIndex,          index of y variables
  int               n                numbers of unknowns
)
  Checks the solution of F(x,y) = 0. This procedure substitutes the solution
  components for the unknowns of F and returns the resulting BDD for F.

  Side Effects: Frees the memory pointed by yIndex.


Cudd_V(
                    node
)
  Returns the value of a constant node. If node is an internal
  node, the result is unpredictable.

  Side Effects: none

DdNode *
Cudd_Xeqy(
  DdManager *       dd,              DD manager
  int               N,               number of x and y variables
  DdNode **         x,               array of x variables
  DdNode **         y                array of y variables
)
  This function generates a BDD for the function x==y. Both x and y are N-bit
  numbers, x[0] x[1] ... x[N-1] and y[0] y[1] ... y[N-1], with 0 the most
  significant bit. The BDD is built bottom-up. It has 3*N-1 internal nodes, if
  the variables are ordered as follows: x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].

  Side Effects: None

DdNode *
Cudd_Xgty(
  DdManager *       dd,              DD manager
  int               N,               number of x and y variables
  DdNode **         z,               array of z variables: unused
  DdNode **         x,               array of x variables
  DdNode **         y                array of y variables
)
  This function generates a BDD for the function x > y. Both x and y are N-
  bit numbers, x[0] x[1] ... x[N-1] and y[0] y[1] ... y[N-1], with 0 the most
  significant bit. The BDD is built bottom-up. It has 3*N-1 internal nodes, if
  the variables are ordered as follows: x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].
  Argument z is not used by Cudd_Xgty: it is included to make it call-
  compatible to Cudd_Dxygtdxz and Cudd_Dxygtdyz.

  Side Effects: None

DdNode *
Cudd_addAgreement(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  Returns NULL if not a terminal case; f op g otherwise, where f op g is f if
  f==g; background if f!=g.

  Side Effects: None

DdNode *
Cudd_addBddInterval(
  DdManager *       dd,
  DdNode *          f,
  CUDD_VALUE_TYPE   lower,
  CUDD_VALUE_TYPE   upper
)
  Converts an ADD to a BDD by replacing all discriminants greater than or
  equal to lower and less than or equal to upper with 1, and all other
  discriminants with 0. Returns a pointer to the resulting BDD if successful;
  NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addBddIthBit(
  DdManager *       dd,
  DdNode *          f,
  int               bit
)
  Converts an ADD to a BDD by replacing all discriminants whose i-th bit is
  equal to 1 with 1, and all other discriminants with 0. The i-th bit refers
  to the integer representation of the leaf value. If the value is has a
  fractional part, it is ignored. Repeated calls to this procedure allow one
  to transform an integer-valued ADD into an array of BDDs, one for each bit
  of the leaf values. Returns a pointer to the resulting BDD if successful;
  NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addBddPattern(
  DdManager *       dd,
  DdNode *          f
)
  Converts an ADD to a BDD by replacing all discriminants different from 0
  with 1. Returns a pointer to the resulting BDD if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_addBddStrictThreshold(
  DdManager *       dd,
  DdNode *          f,
  CUDD_VALUE_TYPE   value
)
  Converts an ADD to a BDD by replacing all discriminants STRICTLY greater
  than value with 1, and all other discriminants with 0. Returns a pointer to
  the resulting BDD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addBddThreshold(
  DdManager *       dd,
  DdNode *          f,
  CUDD_VALUE_TYPE   value
)
  Converts an ADD to a BDD by replacing all discriminants greater than or
  equal to value with 1, and all other discriminants with 0. Returns a pointer
  to the resulting BDD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addCmpl(
  DdManager *       dd,
  DdNode *          f
)
  Computes the complement of an ADD a la C language: The complement of 0 is 1
  and the complement of everything else is 0. Returns a pointer to the
  resulting ADD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addCompose(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g,
  int               v
)
  Substitutes g for x_v in the ADD for f. v is the index of the variable to be
  substituted. g must be a 0-1 ADD. Cudd_bddCompose passes the corresponding
  projection function to the recursive procedure, so that the cache may be
  used. Returns the composed ADD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addComputeCube(
  DdManager *       dd,
  DdNode **         vars,
  int *             phase,
  int               n
)
  Computes the cube of an array of ADD variables. If non-null, the phase
  argument indicates which literal of each variable should appear in the cube.
  If phase[i] is nonzero, then the positive literal is used. If phase is NULL,
  the cube is positive unate. Returns a pointer to the result if successful;
  NULL otherwise.

  Side Effects: none

DdNode *
Cudd_addConstrain(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          c
)
  Computes f constrain c (f @ c), for f an ADD and c a 0-1 ADD. List of
  special cases:   F @ 0 = 0  F @ 1 = F  0 @ c = 0  1 @ c
  = 1  F @ F = 1  Returns a pointer to the result if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_addConst(
  DdManager *       dd,
  CUDD_VALUE_TYPE   c
)
  Retrieves the ADD for constant c if it already exists, or creates a new ADD.
  Returns a pointer to the ADD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addDiff(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  Returns NULL if not a terminal case; f op g otherwise, where f op g is
  plusinfinity if f=g; min(f,g) if f!=g.

  Side Effects: None

DdNode *
Cudd_addDivide(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  Integer and floating point division. Returns NULL if not a terminal case; f
  / g otherwise.

  Side Effects: None

DdNode *
Cudd_addEvalConst(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Checks whether ADD g is constant whenever ADD f is 1. f must be a 0-1 ADD.
  Returns a pointer to the resulting ADD (which may or may not be constant) or
  DD_NON_CONSTANT. If f is identically 0, the check is assumed to be
  successful, and the background value is returned. No new nodes are created.

  Side Effects: None

DdNode *
Cudd_addExistAbstract(
  DdManager *       manager,
  DdNode *          f,
  DdNode *          cube
)
  Abstracts all the variables in cube from f by summing over all possible
  values taken by the variables. Returns the abstracted ADD.

  Side Effects: None

DdNode *
Cudd_addFindMax(
  DdManager *       dd,
  DdNode *          f
)
  Returns a pointer to a constant ADD.

  Side Effects: None

DdNode *
Cudd_addFindMin(
  DdManager *       dd,
  DdNode *          f
)
  Returns a pointer to a constant ADD.

  Side Effects: None

DdNode *
Cudd_addHamming(
  DdManager *       dd,
  DdNode **         xVars,
  DdNode **         yVars,
  int               nVars
)
  Computes the Hamming distance ADD. Returns an ADD that gives the Hamming
  distance between its two arguments if successful; NULL otherwise. The two
  vectors xVars and yVars identify the variables that form the two arguments.

  Side Effects: None

int
Cudd_addHarwell(
  FILE *            fp,              pointer to the input file
  DdManager *       dd,              DD manager
  DdNode **         E,               characteristic function of the graph
  DdNode ***        x,               array of row variables
  DdNode ***        y,               array of column variables
  DdNode ***        xn,              array of complemented row variables
  DdNode ***        yn_,             array of complemented column variables
  int *             nx,              number or row variables
  int *             ny,              number or column variables
  int *             m,               number of rows
  int *             n,               number of columns
  int               bx,              first index of row variables
  int               sx,              step of row variables
  int               by,              first index of column variables
  int               sy,              step of column variables
  int               pr               verbosity level
)
  Reads in a matrix in the format of the Harwell-Boeing benchmark suite. The
  variables are ordered as follows:  x[0] y[0] x[1] y[1] ...
   0 is the most significant bit. On input, nx and ny hold the
  numbers of row and column variables already in existence. On output, they
  hold the numbers of row and column variables actually used by the matrix. m
  and n are set to the numbers of rows and columns of the matrix. Their values
  on input are immaterial. Returns 1 on success; 0 otherwise. The ADD for the
  sparse matrix is returned in E, and its reference count is > 0.

  Side Effects: None

DdNode *
Cudd_addIteConstant(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g,
  DdNode *          h
)
  Implements ITEconstant for ADDs. f must be a 0-1 ADD. Returns a pointer to
  the resulting ADD (which may or may not be constant) or DD_NON_CONSTANT. No
  new nodes are created. This function can be used, for instance, to check
  that g has a constant value (specified by h) whenever f is 1. If the
  constant value is unknown, then one should use Cudd_addEvalConst.

  Side Effects: None

DdNode *
Cudd_addIte(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g,
  DdNode *          h
)
  Implements ITE(f,g,h). This procedure assumes that f is a 0-1 ADD. Returns a
  pointer to the resulting ADD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addIthBit(
  DdManager *       dd,
  DdNode *          f,
  int               bit
)
  Produces an ADD from another ADD by replacing all discriminants whose i-th
  bit is equal to 1 with 1, and all other discriminants with 0. The i-th bit
  refers to the integer representation of the leaf value. If the value is has
  a fractional part, it is ignored. Repeated calls to this procedure allow one
  to transform an integer-valued ADD into an array of ADDs, one for each bit
  of the leaf values. Returns a pointer to the resulting ADD if successful;
  NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addIthVar(
  DdManager *       dd,
  int               i
)
  Retrieves the ADD variable with index i if it already exists, or creates a
  new ADD variable. Returns a pointer to the variable if successful; NULL
  otherwise. An ADD variable differs from a BDD variable because it points to
  the arithmetic zero, instead of having a complement pointer to 1.

  Side Effects: None

int
Cudd_addLeq(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Returns 1 if f is less than or equal to g; 0 otherwise. No new nodes are
  created. This procedure works for arbitrary ADDs. For 0-1 ADDs
  Cudd_addEvalConst is more efficient.

  Side Effects: None

DdNode *
Cudd_addMatrixMultiply(
  DdManager *       dd,
  DdNode *          A,
  DdNode *          B,
  DdNode **         z,
  int               nz
)
  Calculates the product of two matrices, A and B, represented as ADDs. This
  procedure implements the quasiring multiplication algorithm. A is assumed to
  depend on varibles x (rows) and z (columns). B is assumed to depend on
  varibles z (rows) and y (columns). The product of A and B then depends on x
  (rows) and y (columns). Only the z variables have to be explicitly
  identified; they are the "summation" variables. Returns a pointer to the
  result if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addMaximum(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  Integer and floating point max for Cudd_addApply. Returns NULL if not a
  terminal case; max(f,g) otherwise.

  Side Effects: None

DdNode *
Cudd_addMinimum(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  Integer and floating point min for Cudd_addApply. Returns NULL if not a
  terminal case; min(f,g) otherwise.

  Side Effects: None

DdNode *
Cudd_addMinus(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  Integer and floating point subtraction. Returns NULL if not a terminal case;
  f - g otherwise.

  Side Effects: None

DdNode *
Cudd_addNand(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  NAND of two 0-1 ADDs. Returns NULL if not a terminal case; f NAND g
  otherwise.

  Side Effects: None

DdNode *
Cudd_addNegate(
  DdManager *       dd,
  DdNode *          f
)
  Computes the additive inverse of an ADD. Returns a pointer to the result if
  successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addNewVarAtLevel(
  DdManager *       dd,
  int               level
)
  Creates a new ADD variable. The new variable has an index equal to the
  largest previous index plus 1 and is positioned at the specified level in
  the order. Returns a pointer to the new variable if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_addNewVar(
  DdManager *       dd
)
  Creates a new ADD variable. The new variable has an index equal to the
  largest previous index plus 1. Returns a pointer to the new variable if
  successful; NULL otherwise. An ADD variable differs from a BDD variable
  because it points to the arithmetic zero, instead of having a complement
  pointer to 1.

  Side Effects: None

DdNode *
Cudd_addNonSimCompose(
  DdManager *       dd,
  DdNode *          f,
  DdNode **         vector
)
  Given a vector of 0-1 ADDs, creates a new ADD by substituting the 0-1 ADDs
  for the variables of the ADD f. There should be an entry in vector for each
  variable in the manager. This function implements non-simultaneous
  composition. If any of the functions being composed depends on any of the
  variables being substituted, then the result depends on the order of
  composition, which in turn depends on the variable order: The variables
  farther from the roots in the order are substituted first. Returns a pointer
  to the resulting ADD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addNor(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  NOR of two 0-1 ADDs. Returns NULL if not a terminal case; f NOR g otherwise.

  Side Effects: None

DdNode *
Cudd_addOneZeroMaximum(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  Returns 1 if f &gt g (both should be terminal cases) and 0 otherwise. Used
  in conjunction with Cudd_addApply. Returns NULL if not a terminal case.

  Side Effects: None

DdNode *
Cudd_addOrAbstract(
  DdManager *       manager,
  DdNode *          f,
  DdNode *          cube
)
  Abstracts all the variables in cube from the 0-1 ADD f by taking the
  disjunction over all possible values taken by the variables. Returns the
  abstracted ADD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addOr(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  Disjunction of two 0-1 ADDs. Returns NULL if not a terminal case; f OR g
  otherwise.

  Side Effects: None

DdNode *
Cudd_addPermute(
  DdManager *       manager,
  DdNode *          node,
  int *             permut
)
  Given a permutation in array permut, creates a new ADD with permuted
  variables. There should be an entry in array permut for each variable in the
  manager. The i-th entry of permut holds the index of the variable that is to
  substitute the i-th variable. Returns a pointer to the resulting ADD if
  successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addPlus(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  Integer and floating point addition. Returns NULL if not a terminal case;
  f+g otherwise.

  Side Effects: None

int
Cudd_addRead(
  FILE *            fp,              input file pointer
  DdManager *       dd,              DD manager
  DdNode **         E,               characteristic function of the graph
  DdNode ***        x,               array of row variables
  DdNode ***        y,               array of column variables
  DdNode ***        xn,              array of complemented row variables
  DdNode ***        yn_,             array of complemented column variables
  int *             nx,              number or row variables
  int *             ny,              number or column variables
  int *             m,               number of rows
  int *             n,               number of columns
  int               bx,              first index of row variables
  int               sx,              step of row variables
  int               by,              first index of column variables
  int               sy               step of column variables
)
  Reads in a sparse matrix specified in a simple format. The first line of the
  input contains the numbers of rows and columns. The remaining lines contain
  the elements of the matrix, one per line. Given a background value
  (specified by the background field of the manager), only the values
  different from it are explicitly listed. Each foreground element is
  described by two integers, i.e., the row and column number, and a real
  number, i.e., the value. Cudd_addRead produces an ADD that depends on two
  sets of variables: x and y. The x variables (x[0] ... x[nx-1]) encode the
  row index and the y variables (y[0] ... y[ny-1]) encode the column index.
  x[0] and y[0] are the most significant bits in the indices. The variables
  may already exist or may be created by the function. The index of x[i] is
  bx+i*sx, and the index of y[i] is by+i*sy. On input, nx and ny hold the
  numbers of row and column variables already in existence. On output, they
  hold the numbers of row and column variables actually used by the matrix.
  When Cudd_addRead creates the variable arrays, the index of x[i] is bx+i*sx,
  and the index of y[i] is by+i*sy. When some variables already exist
  Cudd_addRead expects the indices of the existing x variables to be bx+i*sx,
  and the indices of the existing y variables to be by+i*sy. m and n are
  set to the numbers of rows and columns of the matrix. Their values on input
  are immaterial. The ADD for the sparse matrix is returned in E, and its
  reference count is > 0. Cudd_addRead returns 1 in case of success; 0
  otherwise.

  Side Effects: nx and ny are set to the numbers of row and column variables.
  m and n are set to the numbers of rows and columns. x and y are possibly
  extended to represent the array of row and column variables. Similarly for
  xn and yn_, which hold on return from Cudd_addRead the complements of the
  row and column variables.

DdNode *
Cudd_addResidue(
  DdManager *       dd,              manager
  int               n,               number of bits
  int               m,               modulus
  int               options,         options
  int               top              index of top variable
)
  Builds an ADD for the residue modulo m of an n-bit number. The modulus must
  be at least 2, and the number of bits at least 1. Parameter options
  specifies whether the MSB should be on top or the LSB; and whther the number
  whose residue is computed is in two's complement notation or not. The macro
  CUDD_RESIDUE_DEFAULT specifies LSB on top and unsigned number. The macro
  CUDD_RESIDUE_MSB specifies MSB on top, and the macro CUDD_RESIDUE_TC
  specifies two's complement residue. To request MSB on top and two's
  complement residue simultaneously, one can OR the two macros:
  CUDD_RESIDUE_MSB | CUDD_RESIDUE_TC. Cudd_addResidue returns a pointer to the
  resulting ADD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addRestrict(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          c
)
  ADD restrict according to Coudert and Madre's algorithm (ICCAD90). Returns
  the restricted ADD if successful; otherwise NULL. If application of restrict
  results in an ADD larger than the input ADD, the input ADD is returned.

  Side Effects: None

DdNode *
Cudd_addRoundOff(
  DdManager *       dd,
  DdNode *          f,
  int               N
)
  Rounds off the discriminants of an ADD. The discriminants are rounded off to
  N digits after the decimal. Returns a pointer to the result ADD if
  successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addScalarInverse(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          epsilon
)
  Computes an n ADD where the discriminants are the multiplicative inverses of
  the corresponding discriminants of the argument ADD. Returns a pointer to
  the resulting ADD in case of success. Returns NULL if any discriminants
  smaller than epsilon is encountered.

  Side Effects: None

DdNode *
Cudd_addSetNZ(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  This operator sets f to the value of g wherever g != 0. Returns NULL if not
  a terminal case; f op g otherwise.

  Side Effects: None

DdNode *
Cudd_addSwapVariables(
  DdManager *       dd,
  DdNode *          f,
  DdNode **         x,
  DdNode **         y,
  int               n
)
  Swaps two sets of variables of the same size (x and y) in the ADD f. The
  size is given by n. The two sets of variables are assumed to be disjoint.
  Returns a pointer to the resulting ADD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addThreshold(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  Threshold operator for Apply (f if f >=g; 0 if f<g). Returns NULL if
  not a terminal case; f op g otherwise.

  Side Effects: None

DdNode *
Cudd_addTimesPlus(
  DdManager *       dd,
  DdNode *          A,
  DdNode *          B,
  DdNode **         z,
  int               nz
)
  Calculates the product of two matrices, A and B, represented as ADDs, using
  the CMU matrix by matrix multiplication procedure by Clarke et al.. Matrix A
  has x's as row variables and z's as column variables, while matrix B has z's
  as row variables and y's as column variables. Returns the pointer to the
  result if successful; NULL otherwise. The resulting matrix has x's as row
  variables and y's as column variables.

  Side Effects: None

DdNode *
Cudd_addTimes(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  Integer and floating point multiplication. Returns NULL if not a terminal
  case; f * g otherwise.

  Side Effects: None

DdNode *
Cudd_addTriangle(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g,
  DdNode **         z,
  int               nz
)
  Implements the semiring multiplication algorithm used in the triangulation
  step for the shortest path computation. f is assumed to depend on varibles x
  (rows) and z (columns). g is assumed to depend on varibles z (rows) and y
  (columns). The product of f and g then depends on x (rows) and y (columns).
  Only the z variables have to be explicitly identified; they are the
  "abstraction" variables. Returns a pointer to the result if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_addUnivAbstract(
  DdManager *       manager,
  DdNode *          f,
  DdNode *          cube
)
  Abstracts all the variables in cube from f by taking the product over all
  possible values taken by the variable. Returns the abstracted ADD if
  successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addVectorCompose(
  DdManager *       dd,
  DdNode *          f,
  DdNode **         vector
)
  Given a vector of 0-1 ADDs, creates a new ADD by substituting the 0-1 ADDs
  for the variables of the ADD f. There should be an entry in vector for each
  variable in the manager. If no substitution is sought for a given variable,
  the corresponding projection function should be specified in the vector.
  This function implements simultaneous composition. Returns a pointer to the
  resulting ADD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addWalsh(
  DdManager *       dd,
  DdNode **         x,
  DdNode **         y,
  int               n
)
  Generates a Walsh matrix in ADD form. Returns a pointer to the matrixi if
  successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_addXeqy(
  DdManager *       dd,              DD manager
  int               N,               number of x and y variables
  DdNode **         x,               array of x variables
  DdNode **         y                array of y variables
)
  This function generates an ADD for the function x==y. Both x and y are N-bit
  numbers, x[0] x[1] ... x[N-1] and y[0] y[1] ... y[N-1], with 0 the most
  significant bit. The ADD is built bottom-up. It has 3*N-1 internal nodes, if
  the variables are ordered as follows: x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].

  Side Effects: None

DdNode *
Cudd_addXnor(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  XNOR of two 0-1 ADDs. Returns NULL if not a terminal case; f XNOR g
  otherwise.

  Side Effects: None

DdNode *
Cudd_addXor(
  DdManager *       dd,
  DdNode **         f,
  DdNode **         g
)
  XOR of two 0-1 ADDs. Returns NULL if not a terminal case; f XOR g otherwise.

  Side Effects: None

DdNode *
Cudd_bddAdjPermuteX(
  DdManager *       dd,
  DdNode *          B,
  DdNode **         x,
  int               n
)
  Rearranges a set of variables in the BDD B. The size of the set is given by
  n. This procedure is intended for the `randomization' of the priority
  functions. Returns a pointer to the BDD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_bddAndAbstract(
  DdManager *       manager,
  DdNode *          f,
  DdNode *          g,
  DdNode *          cube
)
  Takes the AND of two BDDs and simultaneously abstracts the variables in
  cube. The variables are existentially abstracted. Returns a pointer to the
  result is successful; NULL otherwise. Cudd_bddAndAbstract implements the
  semiring matrix multiplication algorithm for the boolean semiring.

  Side Effects: None

DdNode *
Cudd_bddAnd(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Computes the conjunction of two BDDs f and g. Returns a pointer to the
  resulting BDD if successful; NULL if the intermediate result blows up.

  Side Effects: None

int
Cudd_bddApproxConjDecomp(
  DdManager *       dd,              manager
  DdNode *          f,               function to be decomposed
  DdNode ***        conjuncts        address of the first factor
)
  Performs two-way conjunctive decomposition of a BDD. This procedure owes its
  name to the use of supersetting to obtain an initial factor of the given
  function. Returns the number of conjuncts produced, that is, 2 if
  successful; 1 if no meaningful decomposition was found; 0 otherwise. The
  conjuncts produced by this procedure tend to be imbalanced.

  Side Effects: The factors are returned in an array as side effects. The
  array is allocated by this function. It is the caller's responsibility to
  free it. On successful completion, the conjuncts are already referenced. If
  the function returns 0, the array for the conjuncts is not allocated. If the
  function returns 1, the only factor equals the function to be decomposed.

int
Cudd_bddApproxDisjDecomp(
  DdManager *       dd,              manager
  DdNode *          f,               function to be decomposed
  DdNode ***        disjuncts        address of the array of the disjuncts
)
  Performs two-way disjunctive decomposition of a BDD. Returns the number of
  disjuncts produced, that is, 2 if successful; 1 if no meaningful
  decomposition was found; 0 otherwise. The disjuncts produced by this
  procedure tend to be imbalanced.

  Side Effects: The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already referenced.
  If the function returns 0, the array for the disjuncts is not allocated. If
  the function returns 1, the only factor equals the function to be
  decomposed.

DdNode *
Cudd_bddBooleanDiff(
  DdManager *       manager,
  DdNode *          f,
  int               x
)
  Computes the boolean difference of f with respect to the variable with index
  x. Returns the BDD of the boolean difference if successful; NULL otherwise.

  Side Effects: None

DdNode **
Cudd_bddCharToVect(
  DdManager *       dd,
  DdNode *          f
)
  Computes a vector of BDDs whose image equals a non-zero function. The result
  depends on the variable order. The i-th component of the vector depends only
  on the first i variables in the order. Each BDD in the vector is not larger
  than the BDD of the given characteristic function. This function is based on
  the description of char-to-vect in "Verification of Sequential Machines
  Using Boolean Functional Vectors" by O. Coudert, C. Berthet and J. C. Madre.
  Returns a pointer to an array containing the result if successful; NULL
  otherwise. The size of the array equals the number of variables in the
  manager. The components of the solution have their reference counts already
  incremented (unlike the results of most other functions in the package.

  Side Effects: None

DdNode *
Cudd_bddClippingAndAbstract(
  DdManager *       dd,              manager
  DdNode *          f,               first conjunct
  DdNode *          g,               second conjunct
  DdNode *          cube,            cube of variables to be abstracted
  int               maxDepth,        maximum recursion depth
  int               direction        under (0) or over (1) approximation
)
  Approximates the conjunction of two BDDs f and g and simultaneously
  abstracts the variables in cube. The variables are existentially abstracted.
  Returns a pointer to the resulting BDD if successful; NULL if the
  intermediate result blows up.

  Side Effects: None

DdNode *
Cudd_bddClippingAnd(
  DdManager *       dd,              manager
  DdNode *          f,               first conjunct
  DdNode *          g,               second conjunct
  int               maxDepth,        maximum recursion depth
  int               direction        under (0) or over (1) approximation
)
  Approximates the conjunction of two BDDs f and g. Returns a pointer to the
  resulting BDD if successful; NULL if the intermediate result blows up.

  Side Effects: None

DdNode *
Cudd_bddCompose(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g,
  int               v
)
  Substitutes g for x_v in the BDD for f. v is the index of the variable to be
  substituted. Cudd_bddCompose passes the corresponding projection function to
  the recursive procedure, so that the cache may be used. Returns the composed
  BDD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_bddComputeCube(
  DdManager *       dd,
  DdNode **         vars,
  int *             phase,
  int               n
)
  Computes the cube of an array of BDD variables. If non-null, the phase
  argument indicates which literal of each variable should appear in the cube.
  If phase[i] is nonzero, then the positive literal is used. If phase is NULL,
  the cube is positive unate. Returns a pointer to the result if successful;
  NULL otherwise.

  Side Effects: None

DdNode **
Cudd_bddConstrainDecomp(
  DdManager *       dd,
  DdNode *          f
)
  BDD conjunctive decomposition as in McMillan's CAV96 paper. The
  decomposition is canonical only for a given variable order. If canonicity is
  required, variable ordering must be disabled after the decomposition has
  been computed. Returns an array with one entry for each BDD variable in the
  manager if successful; otherwise NULL. The components of the solution have
  their reference counts already incremented (unlike the results of most other
  functions in the package.

  Side Effects: None

DdNode *
Cudd_bddConstrain(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          c
)
  Computes f constrain c (f @ c). Uses a canonical form: (f' @ c) = ( f @ c)'.
  (Note: this is not true for c.) List of special cases:   f @ 0 = 0
   f @ 1 = f  0 @ c = 0  1 @ c = 1  f @ f = 1  f @ f'= 0
   Returns a pointer to the result if successful; NULL otherwise. Note
  that if F=(f1,...,fn) and reordering takes place while computing F @ c, then
  the image restriction property (Img(F,c) = Img(F @ c)) is lost.

  Side Effects: None

double
Cudd_bddCorrelationWeights(
  DdManager *       manager,
  DdNode *          f,
  DdNode *          g,
  double *          prob
)
  Computes the correlation of f and g for given input probabilities. On input,
  prob[i] is supposed to contain the probability of the i-th input variable to
  be 1. If f == g, their correlation is 1. If f == g', their correlation is 0.
  Returns the probability that f and g have the same value. If it runs out of
  memory, returns (double)CUDD_OUT_OF_MEM. The correlation of f and the
  constant one gives the probability of f.

  Side Effects: None

double
Cudd_bddCorrelation(
  DdManager *       manager,
  DdNode *          f,
  DdNode *          g
)
  Computes the correlation of f and g. If f == g, their correlation is 1. If f
  == g', their correlation is 0. Returns the fraction of minterms in the ON-
  set of the EXNOR of f and g. If it runs out of memory, returns
  (double)CUDD_OUT_OF_MEM.

  Side Effects: None

DdNode *
Cudd_bddExistAbstract(
  DdManager *       manager,
  DdNode *          f,
  DdNode *          cube
)
  Existentially abstracts all the variables in cube from f. Returns the
  abstracted BDD if successful; NULL otherwise.

  Side Effects: None

int
Cudd_bddGenConjDecomp(
  DdManager *       dd,              manager
  DdNode *          f,               function to be decomposed
  DdNode ***        conjuncts        address of the array of conjuncts
)
  Performs two-way conjunctive decomposition of a BDD. This procedure owes its
  name to the fact tht it generalizes the decomposition based on the cofactors
  with respect to one variable. Returns the number of conjuncts produced, that
  is, 2 if successful; 1 if no meaningful decomposition was found; 0
  otherwise. The conjuncts produced by this procedure tend to be balanced.

  Side Effects: The two factors are returned in an array as side effects. The
  array is allocated by this function. It is the caller's responsibility to
  free it. On successful completion, the conjuncts are already referenced. If
  the function returns 0, the array for the conjuncts is not allocated. If the
  function returns 1, the only factor equals the function to be decomposed.

int
Cudd_bddGenDisjDecomp(
  DdManager *       dd,              manager
  DdNode *          f,               function to be decomposed
  DdNode ***        disjuncts        address of the array of the disjuncts
)
  Performs two-way disjunctive decomposition of a BDD. Returns the number of
  disjuncts produced, that is, 2 if successful; 1 if no meaningful
  decomposition was found; 0 otherwise. The disjuncts produced by this
  procedure tend to be balanced.

  Side Effects: The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already referenced.
  If the function returns 0, the array for the disjuncts is not allocated. If
  the function returns 1, the only factor equals the function to be
  decomposed.

DdNode *
Cudd_bddIntersect(
  DdManager *       dd,              manager
  DdNode *          f,               first operand
  DdNode *          g                second operand
)
  Computes a function included in the intersection of f and g. (That is, a
  witness that the intersection is not empty.) Cudd_bddIntersect tries to
  build as few new nodes as possible. If the only result of interest is
  whether f and g intersect, Cudd_bddLeq should be used instead.

  Side Effects: None

int
Cudd_bddIsVarEssential(
  DdManager *       manager,
  DdNode *          f,
  int               id,
  int               phase
)
  Determines whether a given variable is essential with a given phase in a
  BDD. Uses Cudd_bddIteConstant. Returns 1 if phase == 1 and f-->x_id, or if
  phase == 0 and f-->x_id'.

  Side Effects: None

DdNode *
Cudd_bddIsop(
  DdManager *       dd,
  DdNode *          L,
  DdNode *          U
)
  Computes a BDD in the interval between L and U with a simple sum-of-produuct
  cover. This procedure is similar to Cudd_zddIsop, but it does not return the
  ZDD for the cover. Returns a pointer to the BDD if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_bddIteConstant(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g,
  DdNode *          h
)
  Implements ITEconstant(f,g,h). Returns a pointer to the resulting BDD (which
  may or may not be constant) or DD_NON_CONSTANT. No new nodes are created.

  Side Effects: None

int
Cudd_bddIterConjDecomp(
  DdManager *       dd,              manager
  DdNode *          f,               function to be decomposed
  DdNode ***        conjuncts        address of the array of conjuncts
)
  Performs two-way conjunctive decomposition of a BDD. This procedure owes its
  name to the iterated use of supersetting to obtain a factor of the given
  function. Returns the number of conjuncts produced, that is, 2 if
  successful; 1 if no meaningful decomposition was found; 0 otherwise. The
  conjuncts produced by this procedure tend to be imbalanced.

  Side Effects: The factors are returned in an array as side effects. The
  array is allocated by this function. It is the caller's responsibility to
  free it. On successful completion, the conjuncts are already referenced. If
  the function returns 0, the array for the conjuncts is not allocated. If the
  function returns 1, the only factor equals the function to be decomposed.

int
Cudd_bddIterDisjDecomp(
  DdManager *       dd,              manager
  DdNode *          f,               function to be decomposed
  DdNode ***        disjuncts        address of the array of the disjuncts
)
  Performs two-way disjunctive decomposition of a BDD. Returns the number of
  disjuncts produced, that is, 2 if successful; 1 if no meaningful
  decomposition was found; 0 otherwise. The disjuncts produced by this
  procedure tend to be imbalanced.

  Side Effects: The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already referenced.
  If the function returns 0, the array for the disjuncts is not allocated. If
  the function returns 1, the only factor equals the function to be
  decomposed.

DdNode *
Cudd_bddIte(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g,
  DdNode *          h
)
  Implements ITE(f,g,h). Returns a pointer to the resulting BDD if successful;
  NULL if the intermediate result blows up.

  Side Effects: None

DdNode *
Cudd_bddIthVar(
  DdManager *       dd,
  int               i
)
  Retrieves the BDD variable with index i if it already exists, or creates a
  new BDD variable. Returns a pointer to the variable if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_bddLICompaction(
  DdManager *       dd,              manager
  DdNode *          f,               function to be minimized
  DdNode *          c                constraint (care set)
)
  Performs safe minimization of a BDD. Given the BDD f of a
  function to be minimized and a BDD c representing the care set,
  Cudd_bddLICompaction produces the BDD of a function that agrees with
  f wherever c is 1. Safe minimization means that
  the size of the result is guaranteed not to exceed the size of
  f. This function is based on the DAC97 paper by Hong et al..
  Returns a pointer to the result if successful; NULL otherwise.

  Side Effects: None

int
Cudd_bddLeq(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Returns 1 if f is less than or equal to g; 0 otherwise. No new nodes are
  created.

  Side Effects: None

DdNode *
Cudd_bddLiteralSetIntersection(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Computes the intesection of two sets of literals represented as BDDs. Each
  set is represented as a cube of the literals in the set. The empty set is
  represented by the constant 1. No variable can be simultaneously present in
  both phases in a set. Returns a pointer to the BDD representing the
  intersected sets, if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_bddMinimize(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          c
)
  Finds a small BDD that agrees with f over c.
  Returns a pointer to the result if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_bddNand(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Computes the NAND of two BDDs f and g. Returns a pointer to the resulting
  BDD if successful; NULL if the intermediate result blows up.

  Side Effects: None

DdNode *
Cudd_bddNewVarAtLevel(
  DdManager *       dd,
  int               level
)
  Creates a new BDD variable. The new variable has an index equal to the
  largest previous index plus 1 and is positioned at the specified level in
  the order. Returns a pointer to the new variable if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_bddNewVar(
  DdManager *       dd
)
  Creates a new BDD variable. The new variable has an index equal to the
  largest previous index plus 1. Returns a pointer to the new variable if
  successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_bddNor(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Computes the NOR of two BDDs f and g. Returns a pointer to the resulting BDD
  if successful; NULL if the intermediate result blows up.

  Side Effects: None

DdNode *
Cudd_bddOr(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Computes the disjunction of two BDDs f and g. Returns a pointer to the
  resulting BDD if successful; NULL if the intermediate result blows up.

  Side Effects: None

DdNode *
Cudd_bddPermute(
  DdManager *       manager,
  DdNode *          node,
  int *             permut
)
  Given a permutation in array permut, creates a new BDD with permuted
  variables. There should be an entry in array permut for each variable in the
  manager. The i-th entry of permut holds the index of the variable that is to
  substitute the i-th variable. Returns a pointer to the resulting BDD if
  successful; NULL otherwise.

  Side Effects: None

DdNode **
Cudd_bddPickArbitraryMinterms(
  DdManager *       dd,              manager
  DdNode *          f,               function from which to pick one minterm
  DdNode **         vars,            array of variables
  int               n,               size of vars
  int               k                number of minterms to find
)
  Picks k on-set minterms evenly distributed from given DD. The minterms are
  in terms of vars. The array vars should contain at
  least all variables in the support of f; if this condition is
  not met the minterms built by this procedure may not be contained in
  f. Builds a BDD for the minterms and returns a pointer to it if
  successful; NULL otherwise. There are three reasons why the procedure may
  fail:   It may run out of memory;  the function f
  may be the constant 0;  the minterms may not be contained in
  f. 

  Side Effects: None

int
Cudd_bddPickOneCube(
  DdManager *       ddm,
  DdNode *          node,
  char *            string
)
  Picks one on-set cube randomly from the given DD. The cube is written into
  an array of characters. The array must have at least as many entries as
  there are variables. Returns 1 if successful; 0 otherwise.

  Side Effects: None

DdNode *
Cudd_bddPickOneMinterm(
  DdManager *       dd,              manager
  DdNode *          f,               function from which to pick one minterm
  DdNode **         vars,            array of variables
  int               n                size of vars
)
  Picks one on-set minterm randomly from the given DD. The minterm is in terms
  of vars. The array vars should contain at least
  all variables in the support of f; if this condition is not met
  the minterm built by this procedure may not be contained in f.
  Builds a BDD for the minterm and returns a pointer to it if successful; NULL
  otherwise. There are three reasons why the procedure may fail:   It
  may run out of memory;  the function f may be the constant
  0;  the minterm may not be contained in f. 

  Side Effects: None

int
Cudd_bddRead(
  FILE *            fp,              input file pointer
  DdManager *       dd,              DD manager
  DdNode **         E,               characteristic function of the graph
  DdNode ***        x,               array of row variables
  DdNode ***        y,               array of column variables
  int *             nx,              number or row variables
  int *             ny,              number or column variables
  int *             m,               number of rows
  int *             n,               number of columns
  int               bx,              first index of row variables
  int               sx,              step of row variables
  int               by,              first index of column variables
  int               sy               step of column variables
)
  Reads in a graph (without labels) given as an adjacency matrix. The first
  line of the input contains the numbers of rows and columns of the adjacency
  matrix. The remaining lines contain the arcs of the graph, one per line.
  Each arc is described by two integers, i.e., the row and column number, or
  the indices of the two endpoints. Cudd_bddRead produces a BDD that depends
  on two sets of variables: x and y. The x variables (x[0] ... x[nx-1]) encode
  the row index and the y variables (y[0] ... y[ny-1]) encode the column
  index. x[0] and y[0] are the most significant bits in the indices. The
  variables may already exist or may be created by the function. The index of
  x[i] is bx+i*sx, and the index of y[i] is by+i*sy. On input, nx and ny
  hold the numbers of row and column variables already in existence. On
  output, they hold the numbers of row and column variables actually used by
  the matrix. When Cudd_bddRead creates the variable arrays, the index of x[i]
  is bx+i*sx, and the index of y[i] is by+i*sy. When some variables already
  exist, Cudd_bddRead expects the indices of the existing x variables to be
  bx+i*sx, and the indices of the existing y variables to be by+i*sy. m and
  n are set to the numbers of rows and columns of the matrix. Their values on
  input are immaterial. The BDD for the graph is returned in E, and its
  reference count is > 0. Cudd_bddRead returns 1 in case of success; 0
  otherwise.

  Side Effects: nx and ny are set to the numbers of row and column variables.
  m and n are set to the numbers of rows and columns. x and y are possibly
  extended to represent the array of row and column variables.

void
Cudd_bddRealignDisable(
  DdManager *       unique
)
  Disables realignment of ZDD order to BDD order.

  Side Effects: None

void
Cudd_bddRealignEnable(
  DdManager *       unique
)
  Enables realignment of the BDD variable order to the ZDD variable order
  after the ZDDs have been reordered. The number of ZDD variables must be a
  multiple of the number of BDD variables for realignment to make sense. If
  this condition is not met, Cudd_zddReduceHeap will return 0. Let
  M be the ratio of the two numbers. For the purpose of
  realignment, the ZDD variables from M*i to (M+1)*i-
  1 are reagarded as corresponding to BDD variable i.
  Realignment is initially disabled.

  Side Effects: None

int
Cudd_bddRealignmentEnabled(
  DdManager *       unique
)
  Returns 1 if the realignment of BDD order to ZDD order is enabled; 0
  otherwise.

  Side Effects: None

DdNode *
Cudd_bddRestrict(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          c
)
  BDD restrict according to Coudert and Madre's algorithm (ICCAD90). Returns
  the restricted BDD if successful; otherwise NULL. If application of restrict
  results in a BDD larger than the input BDD, the input BDD is returned.

  Side Effects: None

DdNode *
Cudd_bddSqueeze(
  DdManager *       dd,              manager
  DdNode *          l,               lower bound
  DdNode *          u                upper bound
)
  Finds a small BDD in a function interval. Given BDDs l and
  u, representing the lower bound and upper bound of a function
  interval, Cudd_bddSqueeze produces the BDD of a function within the interval
  with a small BDD. Returns a pointer to the result if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_bddSwapVariables(
  DdManager *       dd,
  DdNode *          f,
  DdNode **         x,
  DdNode **         y,
  int               n
)
  Swaps two sets of variables of the same size (x and y) in the BDD f. The
  size is given by n. The two sets of variables are assumed to be disjoint.
  Returns a pointer to the resulting BDD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_bddTransfer(
  DdManager *       ddSource,
  DdManager *       ddDestination,
  DdNode *          f
)
  Convert a BDD from a manager to another one. Returns a pointer to the BDD in
  the destination manager if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_bddUnivAbstract(
  DdManager *       manager,
  DdNode *          f,
  DdNode *          cube
)
  Universally abstracts all the variables in cube from f. Returns the
  abstracted BDD if successful; NULL otherwise.

  Side Effects: None

int
Cudd_bddVarConjDecomp(
  DdManager *       dd,              manager
  DdNode *          f,               function to be decomposed
  DdNode ***        conjuncts        address of the array of conjuncts
)
  Conjunctively decomposes one BDD according to a variable. If f
  is the function of the BDD and x is the variable, the
  decomposition is (f+x)(f+x'). The variable is chosen so as to
  balance the sizes of the two conjuncts and to keep them small. Returns the
  number of conjuncts produced, that is, 2 if successful; 1 if no meaningful
  decomposition was found; 0 otherwise.

  Side Effects: The two factors are returned in an array as side effects. The
  array is allocated by this function. It is the caller's responsibility to
  free it. On successful completion, the conjuncts are already referenced. If
  the function returns 0, the array for the conjuncts is not allocated. If the
  function returns 1, the only factor equals the function to be decomposed.

int
Cudd_bddVarDisjDecomp(
  DdManager *       dd,              manager
  DdNode *          f,               function to be decomposed
  DdNode ***        disjuncts        address of the array of the disjuncts
)
  Performs two-way disjunctive decomposition of a BDD according to a variable.
  If f is the function of the BDD and x is the
  variable, the decomposition is f*x + f*x'. The variable is
  chosen so as to balance the sizes of the two disjuncts and to keep them
  small. Returns the number of disjuncts produced, that is, 2 if successful; 1
  if no meaningful decomposition was found; 0 otherwise.

  Side Effects: The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already referenced.
  If the function returns 0, the array for the disjuncts is not allocated. If
  the function returns 1, the only factor equals the function to be
  decomposed.

int
Cudd_bddVarIsDependent(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          var              variable
)
  Checks whether a variable is dependent on others in a function. Returns 1 if
  the variable is dependent; 0 otherwise. No new nodes are created.

  Side Effects: None

DdNode *
Cudd_bddVarMap(
  DdManager *       manager,         DD manager
  DdNode *          f                function in which to remap variables
)
  Remaps the variables of a BDD using the default variable map. A typical use
  of this function is to swap two sets of variables. The variable map must be
  registered with Cudd_SetVarMap. Returns a pointer to the resulting BDD if
  successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_bddVectorCompose(
  DdManager *       dd,
  DdNode *          f,
  DdNode **         vector
)
  Given a vector of BDDs, creates a new BDD by substituting the BDDs for the
  variables of the BDD f. There should be an entry in vector for each variable
  in the manager. If no substitution is sought for a given variable, the
  corresponding projection function should be specified in the vector. This
  function implements simultaneous composition. Returns a pointer to the
  resulting BDD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_bddXnor(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Computes the exclusive NOR of two BDDs f and g. Returns a pointer to the
  resulting BDD if successful; NULL if the intermediate result blows up.

  Side Effects: None

DdNode *
Cudd_bddXorExistAbstract(
  DdManager *       manager,
  DdNode *          f,
  DdNode *          g,
  DdNode *          cube
)
  Takes the exclusive OR of two BDDs and simultaneously abstracts the
  variables in cube. The variables are existentially abstracted. Returns a
  pointer to the result is successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_bddXor(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Computes the exclusive OR of two BDDs f and g. Returns a pointer to the
  resulting BDD if successful; NULL if the intermediate result blows up.

  Side Effects: None

DdNode *
Cudd_zddChange(
  DdManager *       dd,
  DdNode *          P,
  int               var
)
  Substitutes a variable with its complement in a ZDD. returns a pointer to
  the result if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_zddComplement(
  DdManager *       dd,
  DdNode *          node
)
  Computes a complement cover for a ZDD node. For lack of a better method, we
  first extract the function BDD from the ZDD cover, then make the complement
  of the ZDD cover from the complement of the BDD node by using ISOP. Returns
  a pointer to the resulting cover if successful; NULL otherwise. The result
  depends on current variable order.

  Side Effects: The result depends on current variable order.

double
Cudd_zddCountDouble(
  DdManager *       zdd,
  DdNode *          P
)
  Counts the number of minterms of a ZDD. The result is returned as a double.
  If the procedure runs out of memory, it returns CUDD_OUT_OF_MEM. This
  procedure is used in Cudd_zddCountMinterm.

  Side Effects: None

double
Cudd_zddCountMinterm(
  DdManager *       zdd,
  DdNode *          node,
  int               path
)
  Counts the number of minterms of the ZDD rooted at node. This
  procedure takes a parameter path that specifies how many
  variables are in the support of the function.

  Side Effects: None

int
Cudd_zddCount(
  DdManager *       zdd,
  DdNode *          P
)
  Returns an integer representing the number of minterms in a ZDD.

  Side Effects: None

int
Cudd_zddDagSize(
  DdNode *          p_node
)
  Counts the number of nodes in a ZDD. This function duplicates Cudd_DagSize
  and is only retained for compatibility.

  Side Effects: None

DdNode *
Cudd_zddDiffConst(
  DdManager *       zdd,
  DdNode *          P,
  DdNode *          Q
)
  Inclusion test for ZDDs (P implies Q). No new nodes are generated by this
  procedure. Returns empty if true; a valid pointer different from empty or
  DD_NON_CONSTANT otherwise.

  Side Effects: None

DdNode *
Cudd_zddDiff(
  DdManager *       dd,
  DdNode *          P,
  DdNode *          Q
)
  Computes the difference of two ZDDs. Returns a pointer to the result if
  successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_zddDivideF(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Modified version of Cudd_zddDivide. This function may disappear in future
  releases.

  Side Effects: None

DdNode *
Cudd_zddDivide(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Computes the quotient of two unate covers represented by ZDDs. Unate covers
  use one ZDD variable for each BDD variable. Returns a pointer to the
  resulting ZDD if successful; NULL otherwise.

  Side Effects: None

int
Cudd_zddDumpDot(
  DdManager *       dd,              manager
  int               n,               number of output nodes to be dumped
  DdNode **         f,               array of output nodes to be dumped
  char **           inames,          array of input names (or NULL)
  char **           onames,          array of output names (or NULL)
  FILE *            fp               pointer to the dump file
)
  Writes a file representing the argument ZDDs in a format suitable for the
  graph drawing program dot. It returns 1 in case of success; 0 otherwise
  (e.g., out-of-memory, file system full). Cudd_zddDumpDot does not close the
  file: This is the caller responsibility. Cudd_zddDumpDot uses a minimal
  unique subset of the hexadecimal address of a node as name for it. If the
  argument inames is non-null, it is assumed to hold the pointers to the names
  of the inputs. Similarly for onames. Cudd_zddDumpDot uses the following
  convention to draw arcs:   solid line: THEN arcs;  dashed line:
  ELSE arcs.  The dot options are chosen so that the drawing fits on a
  letter-size sheet.

  Side Effects: None

DdNode *
Cudd_zddIntersect(
  DdManager *       dd,
  DdNode *          P,
  DdNode *          Q
)
  Computes the intersection of two ZDDs. Returns a pointer to the result if
  successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_zddIsop(
  DdManager *       dd,
  DdNode *          L,
  DdNode *          U,
  DdNode **         zdd_I
)
  Computes an irredundant sum of products (ISOP) in ZDD form from BDDs. The
  two BDDs L and U represent the lower bound and the upper bound,
  respectively, of the function. The ISOP uses two ZDD variables for each BDD
  variable: One for the positive literal, and one for the negative literal.
  These two variables should be adjacent in the ZDD order. The two ZDD
  variables corresponding to BDD variable i should have indices
  2i and 2i+1. The result of this procedure depends
  on the variable order. If successful, Cudd_zddIsop returns the BDD for the
  function chosen from the interval. The ZDD representing the irredundant
  cover is returned as a side effect in zdd_I. In case of failure, NULL is
  returned.

  Side Effects: zdd_I holds the pointer to the ZDD for the ISOP on successful
  return.

DdNode *
Cudd_zddIte(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g,
  DdNode *          h
)
  Computes the ITE of three ZDDs. Returns a pointer to the result if
  successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_zddIthVar(
  DdManager *       dd,
  int               i
)
  Retrieves the ZDD variable with index i if it already exists, or creates a
  new ZDD variable. Returns a pointer to the variable if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_zddPortFromBdd(
  DdManager *       dd,
  DdNode *          B
)
  Converts a BDD into a ZDD. This function assumes that there is a one-to-one
  correspondence between the BDD variables and the ZDD variables, and that the
  variable order is the same for both types of variables. These conditions are
  established if the ZDD variables are created by one call to
  Cudd_zddVarsFromBddVars with multiplicity = 1. Returns a pointer to the
  resulting ZDD if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_zddPortToBdd(
  DdManager *       dd,
  DdNode *          f
)
  Converts a ZDD into a BDD. Returns a pointer to the resulting ZDD if
  successful; NULL otherwise.

  Side Effects: None

int
Cudd_zddPrintCover(
  DdManager *       zdd,
  DdNode *          node
)
  Prints a sum of products from a ZDD representing a cover. Returns 1 if
  successful; 0 otherwise.

  Side Effects: None

int
Cudd_zddPrintDebug(
  DdManager *       zdd,
  DdNode *          f,
  int               n,
  int               pr
)
  Prints to the standard output a DD and its statistics. The statistics
  include the number of nodes and the number of minterms. (The number of
  minterms is also the number of combinations in the set.) The statistics are
  printed if pr > 0. Specifically:   pr = 0 : prints nothing 
  pr = 1 : prints counts of nodes and minterms  pr = 2 : prints counts +
  disjoint sum of products  pr = 3 : prints counts + list of nodes  pr
  > 3 : prints counts + disjoint sum of products + list of nodes 
  Returns 1 if successful; 0 otherwise.

  Side Effects: None

int
Cudd_zddPrintMinterm(
  DdManager *       zdd,
  DdNode *          node
)
  Prints a disjoint sum of product form for a ZDD. Returns 1 if successful; 0
  otherwise.

  Side Effects: None

void
Cudd_zddPrintSubtable(
  DdManager *       table
)
  Prints the ZDD table for debugging purposes.

  Side Effects: None

DdNode *
Cudd_zddProduct(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Computes the product of two covers represented by ZDDs. The result is also a
  ZDD. Returns a pointer to the result if successful; NULL otherwise. The
  covers on which Cudd_zddProduct operates use two ZDD variables for each
  function variable (one ZDD variable for each literal of the variable). Those
  two ZDD variables should be adjacent in the order.

  Side Effects: None

long
Cudd_zddReadNodeCount(
  DdManager *       dd
)
  Reports the number of nodes in ZDDs. This number always includes the two
  constants 1 and 0.

  Side Effects: None

void
Cudd_zddRealignDisable(
  DdManager *       unique
)
  Disables realignment of ZDD order to BDD order.

  Side Effects: None

void
Cudd_zddRealignEnable(
  DdManager *       unique
)
  Enables realignment of the ZDD variable order to the BDD variable order
  after the BDDs and ADDs have been reordered. The number of ZDD variables
  must be a multiple of the number of BDD variables for realignment to make
  sense. If this condition is not met, Cudd_ReduceHeap will return 0. Let
  M be the ratio of the two numbers. For the purpose of
  realignment, the ZDD variables from M*i to (M+1)*i-
  1 are reagarded as corresponding to BDD variable i.
  Realignment is initially disabled.

  Side Effects: None

int
Cudd_zddRealignmentEnabled(
  DdManager *       unique
)
  Returns 1 if the realignment of ZDD order to BDD order is enabled; 0
  otherwise.

  Side Effects: None

int
Cudd_zddReduceHeap(
  DdManager *       table,           DD manager
  Cudd_ReorderingTy heuristic,       method used for reordering
  int               minsize          bound below which no reordering occurs
)
  Main dynamic reordering routine for ZDDs. Calls one of the possible
  reordering procedures:  Swapping Sifting Symmetric Sifting
   For sifting and symmetric sifting it is possible to request reordering
  to convergence. The core of all methods is the reordering procedure
  cuddZddSwapInPlace() which swaps two adjacent variables. Returns 1 in case
  of success; 0 otherwise. In the case of symmetric sifting (with and without
  convergence) returns 1 plus the number of symmetric variables, in case of
  success.

  Side Effects: Changes the variable order for all ZDDs and clears the cache.

int
Cudd_zddShuffleHeap(
  DdManager *       table,           DD manager
  int *             permutation      required variable permutation
)
  Reorders ZDD variables according to given permutation. The i-th entry of the
  permutation array contains the index of the variable that should be brought
  to the i-th level. The size of the array should be equal or greater to the
  number of variables currently in use. Returns 1 in case of success; 0
  otherwise.

  Side Effects: Changes the ZDD variable order for all diagrams and clears the
  cache.

DdNode *
Cudd_zddSubset0(
  DdManager *       dd,
  DdNode *          P,
  int               var
)
  Computes the negative cofactor of a ZDD w.r.t. a variable. In terms of
  combinations, the result is the set of all combinations in which the
  variable is negated. Returns a pointer to the result if successful; NULL
  otherwise.

  Side Effects: None

DdNode *
Cudd_zddSubset1(
  DdManager *       dd,
  DdNode *          P,
  int               var
)
  Computes the positive cofactor of a ZDD w.r.t. a variable. In terms of
  combinations, the result is the set of all combinations in which the
  variable is asserted. Returns a pointer to the result if successful; NULL
  otherwise.

  Side Effects: None

void
Cudd_zddSymmProfile(
  DdManager *       table,
  int               lower,
  int               upper
)
  Prints statistics on symmetric ZDD variables.

  Side Effects: None

DdNode *
Cudd_zddUnateProduct(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Computes the product of two unate covers represented as ZDDs. Unate covers
  use one ZDD variable for each BDD variable. Returns a pointer to the result
  if successful; NULL otherwise.

  Side Effects: None

DdNode *
Cudd_zddUnion(
  DdManager *       dd,
  DdNode *          P,
  DdNode *          Q
)
  Computes the union of two ZDDs. Returns a pointer to the result if
  successful; NULL otherwise.

  Side Effects: None

int
Cudd_zddVarsFromBddVars(
  DdManager *       dd,              DD manager
  int               multiplicity     how many ZDD variables are created for
                                     each BDD variable
)
  Creates one or more ZDD variables for each BDD variable. If some ZDD
  variables already exist, only the missing variables are created. Parameter
  multiplicity allows the caller to control how many variables are created for
  each BDD variable in existence. For instance, if ZDDs are used to represent
  covers, two ZDD variables are required for each BDD variable. The order of
  the BDD variables is transferred to the ZDD variables. If a variable group
  tree exists for the BDD variables, a corresponding ZDD variable group tree
  is created by expanding the BDD variable tree. In any case, the ZDD
  variables derived from the same BDD variable are merged in a ZDD variable
  group. If a ZDD variable group tree exists, it is freed. Returns 1 if
  successful; 0 otherwise.

  Side Effects: None

DdNode *
Cudd_zddWeakDivF(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Modified version of Cudd_zddWeakDiv. This function may disappear in future
  releases.

  Side Effects: None

DdNode *
Cudd_zddWeakDiv(
  DdManager *       dd,
  DdNode *          f,
  DdNode *          g
)
  Applies weak division to two ZDDs representing two covers. Returns a pointer
  to the ZDD representing the result if successful; NULL otherwise. The result
  of weak division depends on the variable order. The covers on which
  Cudd_zddWeakDiv operates use two ZDD variables for each function variable
  (one ZDD variable for each literal of the variable). Those two ZDD variables
  should be adjacent in the order.

  Side Effects: None

