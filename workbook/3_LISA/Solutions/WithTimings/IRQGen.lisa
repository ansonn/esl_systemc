// This file was generated by System Generator Canvas
// --------------------------------------------------


//
// IRGQGen
// Simple interrupt generating component
// 
// NOTE:
// There is a 10 cycle delay in the signal becoming set
// but no delay when clearing the signal
//

component IRQGen
{
    composition
    {
    pvbusslave : PVBusSlave();
    clocktimer : ClockTimer();
    }

    connection
    {
    	clocktimer.timer_callback => self.timer_callback;    
    	self.timer_control => clocktimer.timer_control;
    	self.clk_in => clocktimer.clk_in;
    
        pvbusslave.device => self.pvbdevice_s;
        self.pvbus_s => pvbusslave.pvbus_s;
        self.control => pvbusslave.control;
    }

  resources
  {
    bool signalState;
  }
  
  behavior init
  {
    control.setAccess(0x00000000, 0x100000, pv::ACCESSTYPE_RW, pv::ACCESSMODE_DEVICE);
    composition.init();
  }

  behavior reset(int level)
  {
    signalState = false;
    composition.reset(level);
  }

  //
  // Bus slave port and pvbus implementation
  //
  slave port<PVBus> pvbus_s; 

  internal master port<PVBusSlaveControl> control;

  internal slave port<PVDevice> pvbdevice_s
  {

    behavior read(pv::ReadTransaction tx):pv::Tx_Result
    {
      switch (tx.getAccessWidth())
      {
        case pv::ACCESS_8_BITS :
          tx.setReturnData8( signalState ? 1 : 0 );
          break;

        case pv::ACCESS_16_BITS :
          tx.setReturnData16( signalState ? 1 : 0 );
          break;

        case pv::ACCESS_32_BITS :
          tx.setReturnData32( signalState ? 1 : 0 );
          break;

        case pv::ACCESS_64_BITS :
          tx.setReturnData64( signalState ? 1 : 0 );
          break;

        default:
          // Unsupported access size!
          // Consider adding an error message here
          return tx.generateSlaveAbort(); 
      }
      return tx.readComplete();
    }

    behavior write(pv::WriteTransaction tx):pv::Tx_Result
    {
      if (signalState == true)
      {
        // Irq currently asserted, so de-assert
        irq.setValue( sg::Signal::Clear);
        signalState = false;
      }
      else
      {
        timer_control.set(10);
      }
  
      return tx.writeComplete();
    }

    behavior debugRead(pv::ReadTransaction tx) : pv::Tx_Result
    {
      return this->pvbdevice_s.read(tx);    
    }
    
    behavior debugWrite(pv::WriteTransaction tx) : pv::Tx_Result
    {   
       return this->pvbdevice_s.write(tx);    
    }
  }

  //
  // Signal master port
  //
  master port<Signal> irq;

  // --------------------------------------------------------
  // Time related
  // --------------------------------------------------------

  internal master port<TimerControl> timer_control;
  
  //
  // INTERNAL PORT: trigger
  //
  internal slave port<TimerCallback> timer_callback
  {
    behavior signal():uint32_t
    {
      if (signalState == false)
      {
        // Irq  currently de-asserted. so assert
        irq.setValue( sg::Signal::Set);
        signalState = true;
      }       

      return 0;
    }
  }

  //
  // Input clock
  //
  slave port<ClockSignal> clk_in;
  //
  // Interrupt signal

}
