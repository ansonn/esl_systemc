// This file was generated by System Generator Canvas
// --------------------------------------------------
component GCD
{
  composition
  {
    clocktimer : ClockTimer();
    pvbusslave : PVBusSlave();
  }

  connection
  {
    self.pvbus_s              => pvbusslave.pvbus_s;
    pvbusslave.device         => self.device;
    self.control              => pvbusslave.control;
    self.clk_in               => clocktimer.clk_in;
    self.timer_control        => clocktimer.timer_control;
    clocktimer.timer_callback => self.timer_callback;
  }

  resources
  {
    REGISTER{type(uint), bitwidth(32)} ctrl_reg; 
    REGISTER{type(uint), bitwidth(32)} irq_reg;
    REGISTER{type(uint), bitwidth(32)} a_reg;
    REGISTER{type(uint), bitwidth(32)} b_reg;
    REGISTER{type(uint), bitwidth(32)} result_reg;
  }

  //
  // Simulation phases
  //

  behavior reset( int level)
  { 
    ctrl_reg  = 0x0;
    irq_reg   = 0x0;

    // Configure access types
    control.setAccess(0x00000000, 0x1000, pv::ACCESSTYPE_RW, pv::ACCESSMODE_DEVICE);

    composition.reset(level);
  }

  //
  // Custom behaviors
  //

  behavior calc_gcd
  {
    uint32_t A     = a_reg;
    uint32_t B     = b_reg;
    uint32_t count = 0;

    while (A != B)
    {
      if (A > B)
      {
        A = A - B;
      }
      else
      {
        B = B - A;
      }
    
      // Record number of iterations required
      count++;  
    }

    // Set result
    result_reg = A; 

    // Start timer, call-back period is based on number of iterations
    timer_control.set(count); 
  }

  behavior set_irq
  {
    // Only signal interrupt if interrupts enabled
    if ( (ctrl_reg & 0x2) != 0)
    {
      irq.setValue(sg::Signal::Set);
      irq_reg = 1;
    }
  }

  behavior clear_irq
  {
    // Clear interrupt
    irq.setValue(sg::Signal::Clear);  
    
    // Clear bit 0 of Interrupt Status register
    irq_reg = 0;
  }

  //
  // Bus slave port
  //
    slave port<PVBus> pvbus_s
    { 
    // Acting as a forwarding port, passing all accesses to PVBusSlave
    // So do not need to implement the behaviors
    }

  //
  // Port 
  //
  internal slave port<PVDevice> device
  {
    //
    // read
    //
        behavior read(pv::ReadTransaction tx):pv::Tx_Result
        {
      // Check access size, only 32 bit supported
            if ( tx.getAccessWidth() != pv::ACCESS_32_BITS )
      {
        return tx.generateAbort();
      }

      // Check which register is being accessed
      switch ( tx.getAddress() )
      {
        case 0x0:
          return tx.setReturnData32(ctrl_reg);
          break;

        case 0x4:
          return tx.setReturnData32(irq_reg);
          break;  

        case 0x8:
          return tx.setReturnData32(a_reg);
          break;  

        case 0xC:
          return tx.setReturnData32(b_reg);
          break;  

        case 0x10:
          return tx.setReturnData32(result_reg);
          break;  

        default:
          return tx.setReturnData32(0x0);
          break;  
      }
      
        }

    //
    // write
    //
        behavior write(pv::WriteTransaction tx):pv::Tx_Result
        {
      // Check access size, only 32 bit supported
            if ( tx.getAccessWidth() != pv::ACCESS_32_BITS )
      {
        return tx.generateAbort();
      }

            // Check which register is being accessed
      switch ( tx.getAddress() )
      {
        case 0x0:
          // Check if Enable bit is set
          if ( (ctrl_reg & 0x01) == 0 )
          {
            // Only bits 1:0 are used, so mask off the rest
            ctrl_reg = tx.getData32() & 0x3;

            // Now check whether to calculate a GCD
            if ( (ctrl_reg & 0x01) == 1 )
            {
              calc_gcd();
            }
          }
          break;

        case 0x4:
          // Writing this register clears the current interrupt
          clear_irq(); 
          break;  

        case 0x8:
          a_reg = tx.getData32();
          break;  

        case 0xC:
          b_reg = tx.getData32(); 
          break;  

        default:
          // NOP
          break;  
      }

      return tx.writeComplete();
        }
  }

  //
  // Control Port for the PVBusSlave sub-component
  //
    internal master port<PVBusSlaveControl> control;

  //
  // Interrupt Port
  //
    master port<Signal> irq
    {
        behavior setValue(sg::Signal::State):void
        {
            // Implemented by slave port
        }

    }

  //
  // Clock-in port
  //
    slave port<ClockSignal> clk_in
  { 
    // Acting as a forwarding port
    }

  //
  // Timer Control Port
  //
    internal master port<TimerControl> timer_control
  {
    // Master port, so functionality implemented in slave
  }

  //
  // Port called by timer at the end of a delay
  //
    internal slave port<TimerCallback> timer_callback
  {
    behavior signal():uint32_t
        { 
      // This will get called after the estimated number
      // of cycles that would have been needed to do the
      // the calculation.
      
      // Signal interrupt
      set_irq();

      // Clear Enable Bit (bit 0), preserve other bits
      ctrl_reg = ctrl_reg & 0xFFFFFFFE;

      return 0;
    }
  }
}
