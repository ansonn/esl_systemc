// This file was generated by System Generator Canvas
// --------------------------------------------------
component ExtMemWrapper
{
    composition
    {
		pvbusslave : PVBusSlave();
    }
    connection
    {
	pvbusslave.device => self.device;
	self.pvbus_s => pvbusslave.pvbus_s;
    }

	includes
	{
		// Include C++ model's header file
		#include "ext_mem_model.h"
	}	

	resources
	{
		PARAMETER {description("Memory Size"), type(uint32_t), default(0x10000000)} size;

		// Pointer to our C++ model object
		ExtMemModel * extMem;
	}

	behavior init
	{
        composition.init();
        // Instansiate C++ model object
		extMem = new ExtMemModel(size);

		// Check the memory was allocated correctly
		if (extMem == NULL)
			cerr << "ExtMemWrapper::init() Failed to construct ExtMemModel" << endl;
	}

	behavior terminate
	{
        composition.terminate();
        // Release memory
		if (extMem != NULL)
			delete extMem;
	}

	behavior reset(int level)
	{
        composition.reset(level); 
		// Call C++ model's reset member function
		if (level == 2 /* HARD RESET */) 
			extMem->reset();	

		// LISA+ defines two levels of reset, SOFT and HARD
		// A SOFT reset puts state variables into a known state
		// A HARD reset puts state variables into a known state - and clears the contents of any memory
		// The C++ model's reset function clears memory, so only need to call this function on a HARD reset
	}	

	//
	// Bus Slave Port
	//
    slave port<PVBus> pvbus_s;
    internal slave port<PVDevice> device
    {

		//
		// Read
		//
        behavior read(pv::ReadTransaction tx):pv::Tx_Result
        {
			unsigned int data, address;

			address = tx.getAddress();

			switch (tx.getAccessWidth())
			{
				case pv::ACCESS_8_BITS :
					data = extMem->read8(address);
					return tx.setReturnData8(data);
					break;

				case pv::ACCESS_16_BITS :
					data = extMem->read16(address);
					return tx.setReturnData16(data);
					break;

				case pv::ACCESS_32_BITS :
					data = extMem->read32(address);
					return tx.setReturnData32(data);
					break;

				default :
					// Access size not supported by C++ model!
					return tx.generateAbort();				
			}
        }

		//
		// Write
		//
        behavior write(pv::WriteTransaction tx):pv::Tx_Result
        {

			unsigned int data, address;

			address = tx.getAddress();

			switch (tx.getAccessWidth())
			{
				case pv::ACCESS_8_BITS :
					data = tx.getData8(); 
					extMem->write8(address, data);
					break;

				case pv::ACCESS_16_BITS :
					data = tx.getData16();
					extMem->write16(address, data);
					break;

				case pv::ACCESS_32_BITS :
					data = tx.getData32();
					extMem->write32(address, data);
					break;

				default :
					// Access size not supported by C++ model!
					return tx.generateAbort();
					break;
			}

			return tx.writeComplete();
        }
        
        behavior debugRead(pv::ReadTransaction tx) : pv::Tx_Result
        {
            return self.device.read(tx);    
        }
    
        behavior debugWrite(pv::WriteTransaction tx) : pv::Tx_Result
        {   
            return self.device.write(tx);    
        }

    }
}